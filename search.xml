<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React&amp;Redux</title>
    <url>/2020/02/24/2.24/</url>
    <content><![CDATA[<ol>
<li><p>利用 webpack 来自定义开发环境，了解了 devServer，plugins，loader 的作用，如何在 package.json 里添加依赖等（还需再看，有些地方不是很理解）。</p>
</li>
<li><p>了解 Bable 的作用 （transpile JS to ECMA5）以及 eslint（代码规范）;</p>
</li>
<li><p>React function 组件的好处：省掉 this 关键字；transpiled 后代码量更少；高信噪比等。</p>
</li>
<li><p>梳理了 Redux 知识点以及 React-Router 的用法：<br>用于处理 复杂数据流、两个没有父子关系组件的交互、两个不同组件操作同样的内容、非分层的数据的情况。<br>三个原理：<br>不能直接改变 store；需要 action 作为 trigger；state 需要被纯函数（reducer）来处理<br>流程图：<br>actions are dispatched to reducers and<br>reducers return a new state then cause the change of store<br>store let each components aware the change using CONNECT(React-Redux)<br>reducers 可以看作绞肉机 每一次的 action 可以被多个 reducers 来 handle。<br>为什么 Redux 要由不可变化的 store？提高了 performance 只需要对比旧 state 和新 state 的 memory reference 就知道是否变化；更加清晰 每次的改变知道在哪变化以及怎么变化；方便 debug。<br>经过 reducer 的 action 返回的是一个新的 state，不会克隆内嵌元素，如果要拷贝整个 state，需要手动克隆内嵌对象（深拷贝）；但是深拷贝是降低 performance 的也是浪费的，只需要克隆已经改变的 object；还会造成不必要的渲染，react 会认为都变化了，但实际上只有子对象变化了。所以就是 redux 里的对比机制变相的提高了 performance。</p>
</li>
<li><p>容器组件和展示组件的区别。<a href="https://www.jianshu.com/p/6fa2b21f5df3" target="_blank" rel="noopener">https://www.jianshu.com/p/6fa2b21f5df3</a></p>
</li>
<li><p>this 指向问题<br>如果 this 所在的 function 是一个 obj 的方法时，则指向这个 obj；如果是属性，则指向父级作用域；<br>如果 this 所在的 function 在全局环境里，则指向 window；<br>如果 this 是在一个回调函数里，则指向 window（forEach 函数的第二个参数可以改变 this 指向）；<br>如果 this 是在一个构造函数里，则指向 new 的实例对象（empty obj）；<br>如果 this 在箭头函数（没有 this）里，则会指向父级作用域的 this 所指向的内容；</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>bable</tag>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>react-router</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>React&amp;JS</title>
    <url>/2020/02/27/2.27/</url>
    <content><![CDATA[<h3 id="JS-异步函数"><a href="#JS-异步函数" class="headerlink" title="JS 异步函数"></a>JS 异步函数</h3><ol>
<li><p>promise：<br><a href="https://juejin.im/post/5b605b035188251a90189c61" target="_blank" rel="noopener">https://juejin.im/post/5b605b035188251a90189c61</a></p>
</li>
<li><p>async-await:<br>更简洁可读性更强的语法糖相比于 promise<br><a href="https://juejin.im/post/5b0399bc518825426f311a3e" target="_blank" rel="noopener">https://juejin.im/post/5b0399bc518825426f311a3e</a></p>
</li>
<li><p>axios：<br>是一个基于 promise 的 HTTP 库，简可以发送 get、post 请求等<br><a href="https://cloud.tencent.com/developer/article/1498443" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1498443</a></p>
</li>
</ol>
<h3 id="youtube-搜索小应用"><a href="#youtube-搜索小应用" class="headerlink" title="youtube 搜索小应用"></a>youtube 搜索小应用</h3><ol>
<li>应用结构：<br><img src="/images/youtube_1.png" alt=""></li>
</ol>
<p>searchBar 是搜索栏组件，videoDetails 是用户所搜索或者点击的视频组件，videoList 是右侧相关视频清单组件，videoItem 是右侧单个渲染视频组件；<br>youtube 是向后台 api 发出请求。</p>
<ol start="2">
<li><p>应用界面：<br><img src="/images/youtube-2.png" alt=""></p>
</li>
<li><p>整体流程：<br>在 App.js 文件中渲染了 searchBar 组件，videoDetail 组件以及 videoList 组件，在 videoList 里渲染了 videoItem 组件。<br>用户输入关键字，会显示首个视频以及右侧的清单；<br>这是通过 App 组件向 searchBar 里传递的异步函数(获取 youtube 数据)，onSubmit 事件处理来调用此异步函数。<br>用户点击右侧视频，会重新渲染页面；<br>这是通过 App 组件向 videoList 里传递的 onVideoSelected 函数，再由 videoList 组件传递给 videoItem，最后再 videoItem 组件里 onClick 事件处理来调用这个 onVideoSelected 函数，在 onVideoSelected 函数会利用 setState 重新更改选择的视频，令 app 组件再次渲染。</p>
</li>
</ol>
<p>整个项目要注意的是没有用 redux，导致传递 props 时最多经过了两个的组件，降低了可读性；在回调函数作为 props 时的处理问题；以及利用 async/await 从 youtube api 调取数据的流程，由 axios.create 创建实例等；</p>
]]></content>
      <tags>
        <tag>promise</tag>
        <tag>javascript</tag>
        <tag>async-await</tag>
        <tag>axios</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>React&amp;JS</title>
    <url>/2020/02/25/2.25/</url>
    <content><![CDATA[<p>今天用 jQuery，bootstrap3.7.3，以及 GitHub api 做了一个小应用，主要是读取用户输入，再返回输入的 username 的基本信息，包括用户头像、followers、仓库等。<br><img src="/images/github_j.png" alt=""></p>
<p>难点在于两次 ajax 的调用，第一次通过用户名获取用户的个人信息，第二次是在第一次结束之后再利用 url+/repos 来获取用户的最新仓库，用 each 方法来遍历整个 repos，再单个渲染；当 fetch 多个元素的时候，还要注意 jQuery append 的用法。<br>另，html 里学会了 target=”_blank”，打开新页面的指令。<br>总结：<br>这次的 jQuery 来写的小程序让我了解了怎么在 jQuery 里用异步调用，以及 bootstrap 的常见 class。</p>
]]></content>
      <tags>
        <tag>project</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>事件捕获及冒泡</title>
    <url>/2020/03/01/3.1/</url>
    <content><![CDATA[<h3 id="DOM-操作-amp-jQuery"><a href="#DOM-操作-amp-jQuery" class="headerlink" title="DOM 操作&amp;jQuery"></a>DOM 操作&amp;jQuery</h3><ol>
<li><p>在 jQuery 里必须是对 jQuery 对象进行操作，所以对象需要被包裹在$(obj)里,比如$(this.obj)</p>
</li>
<li><p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。即 child 事件先处理。<br><img src="https://s2.ax1x.com/2020/03/04/35UlJU.png" alt="alt text"><br>但事件捕获(event capturing)与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。<br>element.addEventListener(event, function, useCapture)<br>true - 事件在捕获阶段执行<br>false- 默认。事件在冒泡阶段执行</p>
</li>
<li><p>我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？<br>非目标元素捕获 -&gt; 目标元素代码顺序 -&gt; 非目标元素冒泡<br><a href="https://blog.csdn.net/moguzhale/article/details/53503044" target="_blank" rel="noopener">https://blog.csdn.net/moguzhale/article/details/53503044</a></p>
</li>
<li><p>阻止冒泡和取消默认事件<br>event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用 event.preventDefault()可以取消默认事件<br><a href="https://www.jianshu.com/p/1fd066b4c0ba" target="_blank" rel="noopener">https://www.jianshu.com/p/1fd066b4c0ba</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2020/03/10/3.10/</url>
    <content><![CDATA[<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol>
<li><p>什么是 Webpack?<br>WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。</p>
</li>
<li><p>为什要使用 WebPack?<br>今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的 JavaScript 代码和一大堆依赖包。为了简化开发的复杂度，有不少好的实践方法<br>a:模块化，让我们可以把复杂的程序细化为小的文件;<br>b:类似于 TypeScript 这种在 JavaScript 基础上拓展的开发语言：使我们能够实现目前版本的 JavaScript 不能直接使用的特性，并且之后还能能装换为 JavaScript 文件使浏览器可以识别。</p>
</li>
<li><p>Webpack 的工作方式是?<br>在 webpack 看来一切都是模块！他会把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个浏览器可识别的 JavaScript 文件。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux middleware</title>
    <url>/2020/02/29/2.29/</url>
    <content><![CDATA[<h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><ol>
<li><p>React 里 this 的指向问题<br>谁调用的 this 就指向谁。eg:constructor 函数里的 this.state、生命周期函数等，这些函数都是由 react 实例来调用的。<br>es6 箭头函数指向父层。eg：一个 onclick 函数；onclick={this.clickFunction} 这里的 this 是 undefined 的，所以在 clickFunction 里的 this 也是 undefined；有两种方法可以解决，第一种是将 clickFunction 变成箭头函数，箭头函数的 this 是指向父级作用域的，也就是 react 实例；第二种是使用 bind 改变 this 的指向。</p>
</li>
<li><p>redux 小点<br>Redux 里 reducers 里的参数 state 要设置为空[ ]；<br>每个 reducer(不同的 function)处理 state 的一个“片段”；<br><code>const rootReducers = combineReducers({reducer 的集合})；</code><br>connect 连接组件和 redux，返回一个 function<br>开发时用来检查 state 对象是否被改变了 redux-immutable-state-invariant 插件；<br>mapStateToProps 实现了让组件获取自己需要的 data，避免了全部渲染；<br>如果没有加 mapdispatchtoprops, 组件实例会自动的把 dispatch 作为 props，允许我们 dispatch action，但需要添加类型检测，</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line">CoursesPage.propTypes = &#123;</span><br><span class="line">  dispatch: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>渲染页面的流程<br><img src="/images/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png" alt=""></p>
</li>
<li><p>Js<br>扩展运算符<br>[…state,{object}] 合并 state 对象与 object 对象，如有重叠，将重叠的属性更新；<br>export<br>export default 对应着直接 import，不需要大括号，可以更改名字 ;<br>export 需要{ }；</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux&amp;JS</title>
    <url>/2020/02/28/2.28/</url>
    <content><![CDATA[<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><ol>
<li><p>React-Redux 将 react 组件绑定到 redux<br>how?provider 组件将 app 连接到 redux store<br>connect 组件将 react 组件连接到 redux store</p>
</li>
<li><p>mapStateToProps<br>去定义 store 里哪一部分 state 你想作为 props 传入；（确定可利用的 state）<br>定义此函数时，组件会 subscribe redux store 的更新，每当 store 更新时，此函数会被调用；<br>mapDispatchToProps<br>去定义哪一 action 你想作为 props 传入给组件；</p>
</li>
</ol>
<h3 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h3><p>把一个 object 和 function 相连，在 function 里的 this 代指这个 object，更改 this 的指向。</p>
<ol>
<li><p>bind<br>bind 会返回一个函数，但不会执行这个函数。<br>var newFunc = functionName.bind(object)<br>newFunc(argumentsOfFunction)</p>
</li>
<li><p>call<br>functionName.call(object,argumentsOfFunction)</p>
</li>
<li><p>apply<br>functionName.apply(object,arrayTypeArguments)</p>
</li>
<li><p>箭头函数与普通函数 this 指向<br>this 永远指向的是最后调用它的对象<br>new 关键字可以改变 this 的指向<br>如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。<br>普通函数 this 指向取决于函数调用的位置; 箭头函数 this 指向取决于函数定义的位置<br><a href="https://www.cnblogs.com/pssp/p/5216085.html" target="_blank" rel="noopener">https://www.cnblogs.com/pssp/p/5216085.html</a><br><a href="https://zhuanlan.zhihu.com/p/47132493" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47132493</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>redux</tag>
        <tag>this</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>express</title>
    <url>/2020/03/11/3.11/</url>
    <content><![CDATA[<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><ol>
<li><p>webpack 作用及流程<br>component 必须返回 jsx，每次当 state 变化，组件重新渲染<br>比如 webpack 会把 jsx 语句转化为 bundle.js<br><a href="https://juejin.im/entry/58a177b0128fe100659d79ef" target="_blank" rel="noopener">webpack 流程介绍</a></p>
</li>
<li><p>express 项目结构<br>其中 app.js 是入口文件，views 文件夹下面放置的是需要渲染的模板文件，package.json 是整个项目的配置文件，.gitignore 文件里面写明文件 pull 到 github 时不需要上传的文件或文件夹，如 node_modules 文件夹。</p>
</li>
<li><p><a href="https://www.zybuluo.com/kexinWeb/note/663277" target="_blank" rel="noopener">app.js</a></p>
</li>
<li><p>js 框架与模板引擎的区别<br>模板引擎，就是将 HTML 模板渲染出最终样子的工具。<br>把动态把数据填充到 HTML 里面，可以在服务器端做，也可以在浏览器端做<br>比如 angular 会根据取到的数据去填充}里的内容，这是在客户端完成的。<br>比如 JSP 会在服务器端去填充{$}里的内容，然后把最终的 html 送到浏览器，这是服务器端完成的。<br>有时候前后端模板引擎会同时使用，即使有前端的模板引擎，后端返回 HTML 有时也是需要的，不仅仅返回是 JSON 数据<br>区别：<br>前后端分离可以大大将服务端的压力分散给客户端，而客户端的计算性能损耗几乎是微乎其微，并且在开发流程上，效率也极大提升，也可以适应敏捷开发。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2020/03/12/3.12/</url>
    <content><![CDATA[<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><ol>
<li><p>redux 作用？<br>随着应用复杂度地不断提升，组件之间的状态通信变得越来越多，组件之间的耦合也变得越来越重。redux 能更好维护的模块间通信。</p>
</li>
<li><p>Redux 的单一状态树<br>所有的 state 都以一个对象树的形式储存在一个单一的 store 中。页面中的所有状态 or 数据，都应该用这种状态树的形式来描述；页面上的任何变化，都应该先去改变这个状态树，然后再通过某种方式实现到页面上。</p>
</li>
<li><p>action</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"CHANGE_TEXT"</span>,</span><br><span class="line">    payload: <span class="string">"Hello"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Action 的任务是描述“发生了什么事情？”，这个函数会返回一个 Action 对象，这个对象里描述了“页面发生了什么”。随后这个对象会被传入到 Reducer 中。</p>
</li>
<li><p>reducer<br>(state, action) =&gt; newState<br>Reducer 的任务是根据传入的 Action 对象去修改状态树。<br>Reducer 是一个纯函数， 根据传入的 当前 state 和 action ，返回一个新的 state 。</p>
</li>
<li><p>Store<br>let store = createStore(Reducer);<br>state 是 store 的映射；<br>Store 就是把 Reducer 和 action 联系到一起的对象。<br>Store 有以下职责：<br>维持应用的 state；<br>提供 getState() 方法获取 state；<br>提供 dispatch(action) 方法更新 state；<br>通过 subscribe(listener) 注册监听器；</p>
</li>
<li><p>异步操作怎么办？<br>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。中间件解决了这个问题。</p>
</li>
<li><p>什么是中间件？<br>中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p>
</li>
</ol>
<p>摘自：<a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">阮一峰</a> <a href="https://zhuanlan.zhihu.com/p/24684803" target="_blank" rel="noopener">知乎 er</a></p>
]]></content>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react+redux 项目流程</title>
    <url>/2020/03/13/3.13/</url>
    <content><![CDATA[<h3 id="restful-Api-资源表现层状态转化"><a href="#restful-Api-资源表现层状态转化" class="headerlink" title="restful Api 资源表现层状态转化"></a>restful Api 资源表现层状态转化</h3><p>资源是一种信息实体，它可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">表现层（Representation）</a>。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。<br>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生<a href="https://www.cnblogs.com/yuri2016/p/7204594.html" target="_blank" rel="noopener">状态转化（State Transfer）</a>。而这种转化是建立在表现层之上的，所以就是表现层状态转化。</p>
<h3 id="react-redux-小项目流程"><a href="#react-redux-小项目流程" class="headerlink" title="react+redux 小项目流程"></a>react+redux 小项目流程</h3><ol>
<li><p>先 render 组件</p>
</li>
<li><p>componentDidMount (最常见的 fetch data 的地方就是在 componentDidMount 里)</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> componentDidMount() &#123;</span><br><span class="line"> <span class="comment">/*因为有 action 被发现</span></span><br><span class="line"><span class="comment">  一被调用立即执行 dispatch function</span></span><br><span class="line"><span class="comment">  store.dispatch(fetchpost());</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">this</span>.props.fetchPosts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>action creator 对 api 请求负责初始化<br>export default axios.create({<br>baseURL: <a href="https://jsonplaceholder.typicode.com" target="_blank" rel="noopener">https://jsonplaceholder.typicode.com</a><br>});</p>
</li>
<li><p>action creator 使用 axios 去做出 api 请求<br>action 会被立刻 dispatch 被 reducers 执行，但是 api 请求是有 delay 的。所以需要异步 action creator，即中间件 redux-thunk 帮助我们能去完成发出请求的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchPosts = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">async</span> (dispatch, getstate) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> json.get(<span class="regexp">/posts);</span></span><br><span class="line"><span class="regexp">dispatch(&#123; type: FETCH_POSTS, payload: response.data &#125;);</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export const fetchUser = id =&gt; async dispatch =&gt; &#123;</span></span><br><span class="line"><span class="regexp">const response = await json.get(`/u</span>sers/$&#123;id&#125;<span class="string">`);</span></span><br><span class="line"><span class="string">dispatch(&#123; type: FETCH_USER, payload: response.data &#125;);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>async 函数返回值是 Promise 对象，给了我们获取 data 的权限。<br>中间件：action creator 返回 function 或者 object，被 dispatch 到中间件，在中间件里会有 if 判断是 function 还是 object；如果是 obj，会直接到 reducers 里；如果是 function，会调用这个 function 以及 dispatch 和 getstate function。</p>
</li>
<li><p>api 返回 data<br>dispatch({ type: FETCH_POSTS, payload: response.data });</p>
</li>
<li><p>action creator 返回一个带有 fetched data 的 action，dispatch 给 reducers。</p>
</li>
<li><p>reducer 接收 action 并且通过 payload 数据返回一个新 state。<br>注意：<br>必须返回除了 undefined 以外的值 []是可以的；<br>state = null，第一次调用 state 默认是 null，表示现在没有被选择的值；<br>第二次调用的时候，state 是由第一次 return 出来的 state 和 action2 产生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = [], action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> FETCH_USER:</span><br><span class="line">      <span class="keyword">return</span> [...state, action.payload];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新的 state 会被作为 props 传入 react 组件，造成重新渲染。store 可以看作是 state 的集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">posts</span>: state.posts &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; fetchPosts &#125;)(PostList);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>restful api</tag>
      </tags>
  </entry>
  <entry>
    <title>express</title>
    <url>/2020/03/14/3.14/</url>
    <content><![CDATA[<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><ol>
<li><p>简介<br>中间件：在 express 应用中，一切皆中间件。各种应用逻辑，如 cookie 解析、会话处理、日志记录、权限校验等，都是通过中间件来完成的。<br>路由：负责寻址。比如用户发送了个 http 请求，该定位到哪个资源，就是路由说了算。<br>模板引擎：负责视图动态渲染。</p>
</li>
<li><p><a href="https://github.scom/nswbmw/N-blog/blob/master/book/3.2%20%E8%B7%AF%E7%94%B1.md/" target="_blank" rel="noopener">express.Router</a></p>
</li>
<li><p>模板引擎是一个将页面模板和数据结合起来生成 html 的工具。<br>app.set(‘views’, path.join(__dirname, ‘views’))// 设置存放模板文件的目录<br>app.set(‘view engine’, ‘ejs’)// 设置模板引擎为 ejs</p>
<p>通过调用 res.render 函数渲染 ejs 模板，res.render 第一个参数是模板的名字，这里是 users 则会匹配 views/users.ejs，第二个参数是传给模板的数据。<br>用 includes 拆分模板组件通常有两个好处：<br>模板可复用，减少重复代码<br>主模板结构清晰</p>
</li>
<li><p>中间件与 next<br>express 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递，如内置的 res.render 其实就是渲染完 html 直接返回给客户端，没有调用 next()，从而没有传递给下一个中间件</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>event-loop</title>
    <url>/2020/03/15/3.15/</url>
    <content><![CDATA[<ol>
<li><p>jQuery 的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作.</p>
</li>
<li><p>JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
</li>
<li><p>异步任务指的是，不进入主线程、而进入任务队列（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。<br>（3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。<br><img src="/images/eventloop.jpg" alt=""></p>
</li>
<li><p>所谓回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。<br>任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，任务队列上第一位的事件就自动进入主线程。</p>
</li>
<li><p>ajax：可以在不重新加载整个网页的情况下，对网页的某部分进行更新。只要是 JS 调用异步通讯组件并使用格式化的数据来更新 web 页面上的内容或操作过程，那么我们用的方法就可算是 AJAX</p>
</li>
</ol>
<p>摘自：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰</a></p>
]]></content>
      <tags>
        <tag>jquery</tag>
        <tag>event loop</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>social network project</title>
    <url>/2020/03/21/3.21/</url>
    <content><![CDATA[<p>今天做的 project 内容是 express 对 server 的配置包括路由以及连接 MongoDB，让我对后端的结构有一个初步的理解。主要是以下几个点：</p>
<ol>
<li>设置 PORT 环境变量并且告诉服务器去哪监听；若没有，本地在 5000 端口 。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>app.use(/api/users, require(./routers/api/users));<br>路由规则是 app.use(path,router)定义的，router 代表一个由 express.Router()创建的对象，在路由对象中可定义多个路由规则。每次将请求发送到服务器时，都会调用各个 app.use（middleware）</p>
</li>
<li><p><a href="https://blog.csdn.net/wthfeng/article/details/53366169" target="_blank" rel="noopener">app.use 和 app.get 的区别</a><br>app.use(path,callback)中的 callback 既可以是 router 对象又可以是函数<br>app.get(path,callback)中的 callback 只能是函数<br>给 app.get(app.post、app.put 同理)赋个路由对象是不行的</p>
</li>
<li><p>获取 mongoURI<br>cluster 连接自己的 app，设置安全地址等</p>
</li>
<li><p>mongodb 连接配置<br>每次用 async 函数时，都要用 try-catch 函数来判断失败情况</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>project</tag>
        <tag>express</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Reat Hooks</title>
    <url>/2020/03/18/3.18/</url>
    <content><![CDATA[<ol>
<li><p>todoList app<br>加深了对 ES6，react hook，Jsx 的理解；<br>useState(initialState) 可以接收新的 state 或者一个返回 state 的函数；</p>
</li>
<li><p>用 Hooks 实现生命周期<br>每次 Render 都有自己的 Props 与 State。<br>每次一 function 结束 rendering，useeffect 就会被调用。</p>
<p>format: useEffect(()=&gt;{}, [state])<br>useEffect 会调用当 state 变化的时候，如果是空数组[],则 hook 不会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch <span class="keyword">from</span> Api</span><br><span class="line">format: useEffect(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(&amp;quot;url&amp;quot;);</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"><span class="keyword">const</span> [item] = data.results;</span><br><span class="line">setPerson(item);</span><br><span class="line">&#125;, [state])</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM 操作<br>DOM 就是浏览器为 JavaScript 提供的一系列接口，通过这些接口我们可以操作 web 页面。<br>document.title 设置文档标题等价于 HTML 的 title 标签。<br>innerHTML 与 outerHTML 的区别？<br>innerHTML：内部 HTML，content<br/>；<br>outerHTML：外部 HTML，<div>content<br/></div>；<br>innerText：内部文本，content；<br>outerText：内部文本，content；<br><img src="/images/html.jpg" alt=""><br>摘自：<a href="https://fenews.org/posts/getting-started-with-react-hooks/" target="_blank" rel="noopener">React Hooks(2019)入门教程</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>project</tag>
        <tag>dom</tag>
        <tag>react hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>backend staff</title>
    <url>/2020/03/19/3.19/</url>
    <content><![CDATA[<ol>
<li><p>mongodb<br>sharded cluster：同一个集合的不同子集分发存储到不同的机器（shard）上，Mongodb 使用 sharding 机制来支持超大数据量，将不同的 CRUD 路由到不同的机器上执行，提到了数据库的吞吐性能。<br>collection：table 的集合。</p>
</li>
<li><p>Mongoose 是在 node.js 环境下对 mongodb 进行便捷操作的对象模型工具</p>
</li>
<li><p>AJAX<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。<br><a href="https://juejin.im/post/587f8dbd570c3522011c0f59" target="_blank" rel="noopener">Ajax 的工作原理</a>相当于在用户和服务器之间加了一个中间层(ajax 引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给 Ajax 引擎自己来做, 只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求。把这些交给了 Ajax 引擎，用户操作起来也就感觉更加流畅了。</p>
</li>
<li><p>jQuery<br><a href="https://www.twle.cn/l/yufei/jquery/jquery-basic-ajax-load.html" target="_blank" rel="noopener">AJAX load</a> 方法可以从服务器加载数据，并把返回的数据放入被选元素中</p>
<p>jQuery <a href="https://www.twle.cn/l/yufei/jquery/jquery-basic-ajax-get-post.html" target="_blank" rel="noopener">get()和 post()方法</a>用于通过 HTTP GET 或 POST 请求从服务器请求数据</p>
<p>jQuery 提供了 children() 和 find() 方法用于向下遍历 DOM 树，以查找元素的后代。<br>jQuery 提供了 parent() 、parents() 和 parentsUntil() 方法用于向上遍历 DOM 树，以查找元素的祖先。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>jquery</tag>
        <tag>ajax</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>react</title>
    <url>/2020/03/22/3.22/</url>
    <content><![CDATA[<ol>
<li><p>除了构造函数和生命周期钩子函数里会自动绑定 this 为当前组件外，其他的都不会自动绑定 <a href="https://sunburst.wang/posts/2019/07/05/react-docs-notes.html#_1-%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">this 的指向</a>为当前组件。<br>如果你在 JSX 里忘记将 this 绑定到 this.handleClick 并把它传入了 onClick，那么当你调用这个函数的时候 this 的值为 undefined。</p>
</li>
<li><p>React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>欢迎&#123;isQbVip &amp;&amp; <span class="tag">&lt;<span class="name">a</span>&gt;</span>请尽快升级为正式 Vip!<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux middleware</title>
    <url>/2020/03/02/3.2/</url>
    <content><![CDATA[<h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><ol>
<li><p>为什么要有中间件：目的是去处理一些在 redux 里的异步问题 store.dispath(action)是瞬时的，如果需要在 redux 里处理异步问题，则需要中间件来处理。</p>
</li>
<li><p>什么是中间件？（From Dan Abramov）<br>It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</p>
</li>
<li><p>实现一个异步功能的计数器？<br>如果在 view 里有一个 button 的 onClick 事件，用户每次点击 button，则会触发 addOne action creator 并且可以 dispatch action；<br>thunk 中间件允许我们 dispatch 出异步 function，它相比 reducers 是不纯净的；<br>然后经过 thunk 中间件，再传递给 reducer 对 action 进行处理，生成全新的 state；<br><img src="https://s2.ax1x.com/2020/03/03/34kEl9.png" alt="alt text"></p>
</li>
<li><p>其与小点<br>applyMiddlewares 作用是将所有中间件组成一个数组，依次执行，要注意中间件的次序；<br>view 和 state 是一一对应的，当 state 变化，view 会被重新渲染；<br>store.dispatch 方法会触发 Reducer 的自动执行；<br>一个 action 可能经过不同的中间件，当 action 不需要再被处理时，中间件会进行自己的“熔断”机制；</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>redux middleware</tag>
      </tags>
  </entry>
  <entry>
    <title>Scss</title>
    <url>/2020/03/23/3.23/</url>
    <content><![CDATA[<h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a><a href="https://zhuanlan.zhihu.com/p/35478792" target="_blank" rel="noopener">scss</a></h3><ol>
<li>变量用来存储需要在 CSS 中复用的信息，例如颜色和字体。</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>是过度的使用嵌套会让产生的 CSS 难以维护，因此是一种不好的实践</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>SASS 能够将代码分割为多个片段，并以 underscore 风格的下划线作为其命名前缀,SASS 会通过这些下划线来辨别哪些文件是 SASS 片段，并且不让片段内容直接生成为 CSS 文件，从而只是在使用@import 指令的位置被导入.</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _reset.scss</span></span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// base.scss</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>混合（Mixin）用来分组那些需要在页面中复用的 CSS 声明，开发人员可以通过向 Mixin 传递变量参数来让代码更加灵活</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>) &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-radius(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码建立了一个名为 border-radius 的 Mixin，并传递了一个变量$radius 作为参数，然后在后续代码中通过@include border-radius(10px)使用该 Mixin，最终编译的结果如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>继承是 SASS 中非常重要的一个特性，可以通过@extend 指令在选择器之间复用 CSS 属性，并且不会产生冗余的代码</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。</span></span><br><span class="line">%other-styles &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。</span></span><br><span class="line">%message-common &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>操作符<br>SASS 提供了标准的算术运算符，例如+、-、*、/、%。</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role="complementary"]</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Scss 允许 CSS 规则嵌套使用，父子规则将会呈现包含选择器的关系,可以避免重复的使用父级选择器，从而达到简化 CSS 代码结构的目的.<br>Scss 使用$关键字在 CSS 规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===== SCSS =====*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line">&amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>Scss 当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下</li>
</ol>
]]></content>
      <tags>
        <tag>Scss</tag>
      </tags>
  </entry>
  <entry>
    <title>express</title>
    <url>/2020/03/24/3.24/</url>
    <content><![CDATA[<ol>
<li><p>express</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(express); <span class="keyword">const</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(listening on <span class="number">3000</span>) &#125;)</span><br></pre></td></tr></table></figure>

<p>Express 处理 GET 请求通过 get method:<br>app.get(path, callback)<br>path 是 domain 后面的内容，callback 是当路径匹配时 server 将要做什么；<br>app.get(/, function(req, res) { res.send(Hello World) })<br>用 respons 给浏览器写一个”Hello World”；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="regexp">/, (req, res) =&gt; &#123; res.sendFile(\_\_dirname + /i</span>ndex.html) &#125;)</span><br></pre></td></tr></table></figure>

<p>将 index.html 页面放回到浏览器中</p>
<p>仅当 POST 请求发送到服务器时，CREATE 操作才由浏览器执行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">/quotes</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">placeholder</span>=<span class="string">name</span> <span class="attr">name</span>=<span class="string">name</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">placeholder</span>=<span class="string">quote</span> <span class="attr">name</span>=<span class="string">quote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">submit</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>action 属性告诉浏览器在我们的 Express 应用中导航到的位置。在这种情况下，我们导航到/ quotes。method 属性告诉浏览器发送什么请求。在这种情况下，这是一个 POST 请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="regexp">/quotes, (req, res) =&gt; &#123; console.log(Hello!) &#125;)</span></span><br></pre></td></tr></table></figure>

<p>重新启动服务器并刷新浏览器。然后，在表单元素中输入一些内容。能够看到 Hello！在命令行中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser= <span class="built_in">require</span>(body-parser)app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">true</span>&#125;))</span><br></pre></td></tr></table></figure>

<p>Express 允许我们使用 use 方法向应用程序中添加诸如 body-parser 之类的中间件。在处理 Express 时，经常听到“中间件”一词。这些东西基本上是在我们的应用程序处理它们之前更改请求或响应对象的插件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="regexp">/quotes, (req, res) =&gt; &#123; console.log(req.body) &#125;)</span></span><br></pre></td></tr></table></figure>

<p>body-parser 中的 urlencoded 方法告诉 body-parser 从<form>元素中提取数据并将其添加到请求对象的 body 属性中。</p>
</li>
<li><p>node<br>npm install nodemon –save-dev<br>–save-dev 标志会将 Nodemon 保存为您的 package.json 文件中的 devDependency。<br>{ // … scripts: { dev: nodemon server.js } // … }<br>现在可以运行 npm run dev 来触发 nodemon server.js。</p>
<p>npm install mongodb –save<br>collection 是一个存东西的命名空间.</p>
</li>
<li><p>9321ass<br>9321 这次的 assignment 主要用 flask 框架和数据库交互来写 api，数据是从网页的 json 格式数据读到数据库里，然后将数据渲染在 swagger-ui 页面上，有 7 个不同的功能（增删改查）。主要运用了 Flask-RESTful 和 sqlite 等包。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>express</tag>
        <tag>unsw</tag>
      </tags>
  </entry>
  <entry>
    <title>this keyword of react</title>
    <url>/2020/03/29/3.29/</url>
    <content><![CDATA[<ol>
<li><p>react 中 this 指向<br>发现还是对 this 指向掌握不明确，看完这个博客清晰多了。<br>React 是通过创建虚拟 DOM，然后将虚拟 DOM 生成真实的 DOM，最后插入到页面中，而 React 生命周期中 render 方法的作用就是将虚拟 DOM 渲染成真实 DOM。在 JSX 语法中: onClick={ function } onClick 这个属性本身只是一个”中间变量”。将函数赋值给 onClick 这个中间变量，后面不仅要进行 JSX 语法转化,将 JSX 组件转换成 Javascript 对象,还要再将 Javascript 对象转换成真实 DOM。<br>前提：JS 中的 this 是由函数调用者调用的时候决定的。把 onClick 作为中间变量,指向一个函数的时候,后面的一系列处理中，使用 onClick 这个中间变量所指向的函数，里面的 this 自然就丢失掉了，不是再指向对象实例了。</p>
</li>
<li><p>实例</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  name: <span class="string">"jack"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">test.getName();</span><br><span class="line"><span class="comment">//使用node test.js执行上述代码可以正常输出jack。 之后，我们对代码进行调整：</span></span><br><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  name: <span class="string">"jack"</span>,</span><br><span class="line">  getJack: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果传递一个函数名给一个变量，之后通过函数名()的方式进行调用，在方法内部如果使用this则this的指向会丢失</span></span><br><span class="line"><span class="keyword">const</span> func = test.getJack;</span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们没有直接调用对象的方法，而是将方法声明给一个中间变量，之后利用中间变量()调用方法，此时 this 则失去指向，输出 undefined，如果使用 node 环境执行 js 文件则输出 node 相关信息，如嵌入到 html 中则 this 指向 window 对象。</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>React 事件绑定<br>React 中的 bind 同上方原理一致,在 JSX 中传递的事件不是一个字符串，而是一个函数（如:onClick={this.handleClick}），此时 onClick 即是中间变量，所以处理函数中的 this 指向会丢失。解决这个问题就是给调用函数时 bind(this)，从而使得无论事件处理函数如何传递，this 指向都是当前实例化对象。 当然，如果不想使用 bind(this)，我们可以在声明函数时使用箭头函数将函数内容返回给一个变量，并在调用时直接使用 this.变量名即可。<br><img src="/images/this.png" alt=""></p>
</li>
<li><p>React 没有自动的把 bind 集成到 render 方法中呢?<br>因为 render 多次调用每次都要 bind 会影响性能，所以官方建议 constructor 中手动 bind 达到性能优化。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>css box model and positioning</title>
    <url>/2020/03/03/3.3/</url>
    <content><![CDATA[<h3 id="css-box-model"><a href="#css-box-model" class="headerlink" title="css box model"></a>css box model</h3><ol>
<li><p>所有元素在 css 里都会是一个 box； margin 是该 box 与其他 box 的距离，而 padding 是该盒子边界与内容区的距离</p>
</li>
<li><p>当两个 box 相邻时，margin 会塌陷（重叠），选 box margin 大的那一个作为距离</p>
</li>
<li><p>box-sizing 属性：border-box，内容区宽度或高度会自动调整<br>padding + border + 内容 width= 盒子的宽度<br>padding+ border + 内容 height = 盒子的高度<br><img src="https://s2.ax1x.com/2020/03/04/35aepD.png" alt="alt text"></p>
</li>
</ol>
<h3 id="css-positioning"><a href="#css-positioning" class="headerlink" title="css positioning"></a>css positioning</h3><ol>
<li><p>postion： 默认是 static relative 允许对元素的位置进行操作</p>
</li>
<li><p>absolute：相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。条件是定位基点（一般是父元素）不能是 static 定位， 否则定位基点是 html。</p>
</li>
<li><p>fixed：相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。</p>
</li>
<li><p>sticky：一些时候是 relative 定位（定位基点是自身默认位置），另一些时候自动变成 fixed 定位（定位基点是视口）</p>
</li>
</ol>
<p>摘自：<a href="https://www.ruanyifeng.com/blog/2019/11/css-position.html" target="_blank" rel="noopener">阮一峰教程</a></p>
]]></content>
      <tags>
        <tag>css box model</tag>
        <tag>css positioning</tag>
      </tags>
  </entry>
  <entry>
    <title>react-router</title>
    <url>/2020/03/28/3.28/</url>
    <content><![CDATA[<ol>
<li><p>前端路由与后端路由<br>后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2007/11/mvc.html" target="_blank" rel="noopener">MVC</a><br>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。<br>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。<br>1）最上面的一层，是直接面向最终用户的视图层（View）。它是提供给用户的操作界面，是程序的外壳。<br>2）最底下的一层，是核心的数据层（Model），也就是程序需要操作的数据或信息。<br>3）中间的一层，就是控制层（Controller），它负责根据用户从视图层输入的指令，选取数据层中的数据，然后对其进行相应的操作，产生最终结果。<br>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。</p>
</li>
<li><p>SPA Single Page Application<br>单页应用程序是一个 Web 应用程序，其中客户端 JavaScript 处理路由而不是后端。优点有：<br>SPA 非常易于部署到生产环境中。<br>SPA 快速且易于使用，因为您不必等待重新加载页面。<br>应用程序会动态加载状态。由于该应用程序使用较少的带宽，并且该应用程序的整体性能超过了典型的前端/后端应用程序的性能，因此可以改善用户体验。</p>
</li>
<li><p>复习 sql<br>GROUP BY–根据(by)一定的规则进行分组(Group)。 它的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对若干个小区域进行数据处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customer,<span class="keyword">SUM</span>(OrderPrice) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customer <span class="comment">----查找每个客户的总金额</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="comment">--在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。</span></span><br><span class="line"><span class="keyword">SELECT</span> Customer,<span class="keyword">SUM</span>(OrderPrice) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> Customer=<span class="string">"Bush"</span> <span class="keyword">OR</span> Customer=<span class="string">"Adams"</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customer</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(OrderPrice)&gt;<span class="number">1500</span><span class="comment">----查找客户 Bush 或 Adams 拥有超过 1500 的订单总金额</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>react-router<br>路由器对象有两种类型。浏览器路由器哈希路由器如果我们要处理动态请求，请使用 BrowserRouter；如果要处理静态请求，请使用 HashRouter。</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App"</span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &#123;<span class="string">" "</span>&#125;</span><br><span class="line">    &lt;App /&gt;&#123;<span class="string">" "</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById("root")</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/three compoents:home,contract,about</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/app.js</span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Router&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;h2&gt;Welcome to React Router Tutorial&lt;/</span>h2&gt;</span><br><span class="line">          &lt;nav className=<span class="string">"navbar navbar-expand-lg navbar-light bg-light"</span>&gt;</span><br><span class="line">            &lt;ul className=<span class="string">"navbar-nav mr-auto"</span>&gt;</span><br><span class="line">              &lt;li&gt;</span><br><span class="line">                &lt;Link to=&#123;<span class="string">"/"</span>&#125; className=<span class="string">"nav-link"</span>&gt;</span><br><span class="line">                  Home</span><br><span class="line">                &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>li&gt;</span><br><span class="line">              &lt;li&gt;</span><br><span class="line">                &lt;Link to=&#123;<span class="string">"/contact"</span>&#125; className=<span class="string">"nav-link"</span>&gt;</span><br><span class="line">                  Contact</span><br><span class="line">                &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>li&gt;</span><br><span class="line">              &lt;li&gt;</span><br><span class="line">                &lt;Link to=&#123;<span class="string">"/about"</span>&#125; className=<span class="string">"nav-link"</span>&gt;</span><br><span class="line">                  About</span><br><span class="line">                &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>li&gt;</span><br><span class="line">            &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>nav&gt;</span><br><span class="line">          &lt;hr /&gt;</span><br><span class="line">          &lt;Switch&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/contact"</span> component=&#123;Contact&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">          &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Router 是 react 路由的外层盒子，里面的内容就是单页面应用的路由以及路由组件。Router 下面只能包含一个盒子标签，类似这里的 div。</p>
<p>Link 是点击切换到哪一组件的链接。Link 代表一个链接，在 html 界面中会解析成 a 标签。作为一个链接，必须有一个 to 属性，代表链接地址。这个链接地址是一个相对路径。</p>
<p>Route 代表路由有一个 path 和一个组件属性（也以 component、render 等等）。path 代表相对路径，component 代表组件。</p>
<p>Switch 只会渲染第一个路径，不用则会使每一个被匹配到的 Route 都会被渲染。只找到第一个被 location 匹配到的 route 就停止匹配。</p>
]]></content>
      <tags>
        <tag>react-router</tag>
        <tag>sql</tag>
        <tag>SPA</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>React 的生命周期</title>
    <url>/2020/03/30/3.30/</url>
    <content><![CDATA[<ol>
<li><p>Virtual DOM 工作原理<br>Virtual DOM 是一个轻量级的 JavaScript 对象。它是一个节点树，将元素、它们的属性和内容作为对象及其属性，可以理解为树上的每个节点。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。<br>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。<br>计算之前 DOM 表示与新表示的之间的差异。<br>完成计算后，将只用实际更改的内容更新 real DOM。</p>
</li>
<li><p><a href="https://juejin.im/post/5b077f04f265da0dc073caa6" target="_blank" rel="noopener">React 的生命周期方法有哪些</a><br>componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。<br>componentDidMount：在第一次渲染之后执行，可以在这里做 AJAX 请求，DOM 的操作或状态更新以及设置事件监听器。<br>componentWillReceiveProps：在初始化 render 的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染<br>shouldComponentUpdate：确定是否更新组件。默认情况下，它返回 true。如果确定在 state 或 props 更新后组件不需要在重新渲染，则可以返回 false，这是一个提高性能的方法。<br>componentWillUpdate：在 shouldComponentUpdate 返回 true 确定要更新组件之前执行。<br>componentDidUpdate：它主要用于更新 DOM 以响应 props 或 state 更改。<br>componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>this</tag>
        <tag>virtual dom</tag>
        <tag>lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>css flex box</title>
    <url>/2020/03/04/3.4/</url>
    <content><![CDATA[<h3 id="css-flex-box"><a href="#css-flex-box" class="headerlink" title="css flex box"></a>css flex box</h3><p>在 flex 布局中，flex 项（就是子元素）要么按照 main axis(主轴)（从 main-start 到 main-end ）排布，要么按照 cross axis(交叉轴) (从 cross-start 到 cross-end)排布。了解六个容器属性等。</p>
<p>两个极好的教程:<br><a href="https://www.html.cn/archives/8629" target="_blank" rel="noopener">CSS3 Flexbox 布局完全指南</a><br><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰</a></p>
<p><img src="/images/background.png" alt=""></p>
]]></content>
      <tags>
        <tag>css flex box</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/08/3.8/</url>
    <content><![CDATA[<p>今天算是做完了 9321 的第一个 assignment，考察了对 python 里几个包的运用，pandas、matplotlib 等，主要是用 python 进行数据处理和可视化，还是蛮简单的。</p>
<p>顺便记录一下 <a href="https://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">git</a> 的基本操作。</p>
]]></content>
      <tags>
        <tag>unsw</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>css grid</title>
    <url>/2020/03/05/3.5/</url>
    <content><![CDATA[<h3 id="css-grid"><a href="#css-grid" class="headerlink" title="css grid"></a>css grid</h3><ol>
<li>grid 构成</li>
</ol>
<p>Grid Container) 应用 display: grid 的元素<br>网格项(Grid Item) 网格容器（Grid Container）的子元素（例如直接子元素）<br>网格线(Grid Line) 网格轨道(Grid Track) 网格单元格(Grid Cell) 网格区域(Grid Area)</p>
<ol start="2">
<li><p>grid 属性<br>学习了各种网格容器属性以及网格项属性；<br>两个教程：<br><a href="https://www.html.cn/archives/8510" target="_blank" rel="noopener">https://www.html.cn/archives/8510</a><br><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p>
</li>
<li><p>网格容器与网格项结构<br><img src="/images/grid-1.png" alt=""><br><img src="/images/grid-2.png" alt=""></p>
</li>
<li><p>属性分为三大类：<br>grid container;grid item;以及 grid 里的 content</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>css grid</tag>
      </tags>
  </entry>
  <entry>
    <title>Node</title>
    <url>/2020/03/07/3.7/</url>
    <content><![CDATA[<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol>
<li><p>为什么说 nodejs 是单线程语言呢？这是因为 nodejs 中 javascript 代码的执行是单线程；但 node 确实只有一个主线程，但是底层工作的线程却有多个。遇到异步时，主线程发出操作指令，然后就可以去做别的事情了（主线程不需要等待），所有操作完成后再执行回调。主线程什么时候知道操作完成执行回调，则通过 event loop 机制循环遍历。</p>
</li>
<li><p>nodejs 的异步 IO<br>当需要 IO(网络 IO/文件 IO)操作时，单线程的 javascript 并不会停下来等待 IO 操作完成，而是“事件驱动”开始介入，javascript 执行线程继续执行未完的 javascript 代码，当执行完成后该线程处于空闲状态</p>
</li>
<li><p>事件循环<br><img src="/images/node_sys.png" alt=""><br>Node.js 应用启动时，V8 引擎会执行你写的应用代码，保持一份观察者（注册在事件上的回调函数）列表。当事件发生时，它的回调函数会被加进一个事件队列。只要这个队列还有等待执行的回调函数，事件循环就会持续把回调函数从队列中拿出并执行。</p>
</li>
</ol>
<p>4.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module 是一个 obj，有一个 exports 属性导出 function 或者 obj</span></span><br><span class="line"><span class="built_in">module</span>.exports.func = func</span><br><span class="line"><span class="built_in">module</span>.exports.endPoint = url (keep url private)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./相对路径"</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">const</span> pathObj = path.parse(\_\_filename)</span><br><span class="line"><span class="comment">//包含 dir 地址，root，name 等属性</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>)</span><br><span class="line"><span class="comment">//包含内存等等属性</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks</title>
    <url>/2020/03/09/3.9/</url>
    <content><![CDATA[<h3 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h3><ol>
<li><p>React 的核心思想是，一个 UI 组件响应一个 state 变化。</p>
</li>
<li><p>不使用 setState 更新 React 中的 state。<br>React 组件不再是 ES6 class，它是一个纯粹而简单的 JavaScript 函数。<br>const [buttonText, setButtonText] = useState(“Click me, please”);<br>[state 值,state 更新函数]</p>
</li>
<li><p>useEffect 获取数据替代 componentDidMount 在 React 中获取数据。<br>useEffect 与 React 类中的 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途，但统一为单个 API。<br>比如，在 useEffect 中调用 fetch。而且可以使用 setData（从 useState 中提取的更新函数）代替 this.setState。<br>“useEffect 与 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途”<br>componentDidUpdate！ componentDidUpdate 是一个生命周期方法，每当组件获得新的 props 或 state 发生变化时就会运行。如果直接调用 useEffect，你会看到无限循环。我们需要传递一个空数组作为 useEffect 的第二个参数：[]。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">"http://localhost:3001/links/"</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> setData(data));</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>使用带有 React Hooks 的 render props 吗？<br>没有意义。那是因为 React Hooks 诞生的原因的：在组件之间共享逻辑。有了一个标准的、干净的方式来封装和共享逻辑。</p>
</li>
<li><p>可以在 useEffect 中使用 async/await 吗?<br>不能直接使用。那是因为 JavaScript 异步函数总是返回一个 promise，而 useEffect 只能返回另一个函数。如果你要在 useEffect 中使用 setInterval 定时器，我们应该返回一个函数（闭包）来清除 setInterval。</p>
</li>
</ol>
<p>摘自：<a href="https://fenews.org/posts/getting-started-with-react-hooks/" target="_blank" rel="noopener">React Hooks(2019)入门教程</a></p>
]]></content>
      <tags>
        <tag>react hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>compare</title>
    <url>/2020/04/12/4.12/</url>
    <content><![CDATA[<ol>
<li>mongodb 和 mysql 的对比<br><img src="/images/mysql.png" alt=""></li>
</ol>
<p>MySQL MongoDB<br>表 集合<br>行 文档<br>列 字段<br>joins 嵌入文档或者链接</p>
<ol start="2">
<li>TDD 和 BDD<br>TDD 的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码<br>BDD 的原理是鼓励软件项目中的开发者、QA 和非技术人员或商业参与者之间的协作,行为驱动是从用户的需求出发，强调系统行为</li>
</ol>
]]></content>
      <tags>
        <tag>this</tag>
        <tag>jsx</tag>
        <tag>tdd</tag>
      </tags>
  </entry>
  <entry>
    <title>JS</title>
    <url>/2020/03/06/3.6/</url>
    <content><![CDATA[<h3 id="JS-高阶函数"><a href="#JS-高阶函数" class="headerlink" title="JS 高阶函数"></a>JS 高阶函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forEach</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="comment">//handle in this array not a new array;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">const</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="comment">//handle in a new array;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//filter</span></span><br><span class="line"><span class="keyword">const</span> evens = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//return true or false;</span></span><br><span class="line">  <span class="comment">//true will put the item back to the new array</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce</span></span><br><span class="line"><span class="keyword">const</span> evens = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//prev item and next item will do some kind of calculation;</span></span><br><span class="line">  <span class="comment">//return a number</span></span><br><span class="line">&#125;, randomNumAsStartNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//some,every return true or false;</span></span><br><span class="line"><span class="comment">//some: if any item satisfy the condition,return true</span></span><br><span class="line"><span class="comment">//every: if all items satisfy the condition,return true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>this keyword of react</title>
    <url>/2020/04/01/4.1/</url>
    <content><![CDATA[<ol>
<li><p>为什么用 react hooks？<br>允许创建每个组件为函数组件。<br>更简单的在组件中分享状态逻辑。</p>
</li>
<li><p>React Fragments<br>React 中常见模式是为一个组件返回多个元素。为了包裹多个元素你肯定写过很多的 div 和 span，进行不必要的嵌套，无形中增加了浏览器的渲染压力。Fragments 简写形式&lt;&gt;&lt;/&gt;。</p>
</li>
<li><p>this 指向</p>
</li>
</ol>
<p>普通函数 this 指向函数的调用对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> user = <span class="string">"XX"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.user); <span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">//这里f 的调用等同于window.f(); 所以f函数内部this指向的是window</span></span><br></pre></td></tr></table></figure>

<p>对象方法中调用 —- this 指向上级对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">user:<span class="string">"xxx"</span>,</span><br><span class="line">fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.user); <span class="comment">//xxx</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要注意一点，就是在对象中可能有多层嵌套的对象，但是this指向的都是他调用地方的上级对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">user:<span class="string">"xxx"</span>,</span><br><span class="line">b: &#123;</span><br><span class="line">user: <span class="string">"bbb"</span>,</span><br><span class="line">fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.user); <span class="comment">// bbb</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">obj.b.fn();</span><br><span class="line"><span class="comment">//如上，虽然是在obj里面this调用，但是因为是在obj.b这个对象中，所以this指向的是 obj.b</span></span><br><span class="line"></span><br><span class="line">注意不能只看上级对象，更关键的是调用对象</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">user:<span class="string">"xxx"</span>,</span><br><span class="line">b: &#123;</span><br><span class="line">user: <span class="string">"bbb"</span>,</span><br><span class="line">fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.user); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = obj.b.fn;</span><br><span class="line">f()</span><br><span class="line"><span class="comment">//如上，this其实是在f执行的时候调用的，这时候，f的this的调用对象是window,那么就可以理解window.user为undefined</span></span><br></pre></td></tr></table></figure>

<p>构造函数 — this 指向 new 出来的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.user = <span class="string">"xxx;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">var a = new Fn();</span></span><br><span class="line"><span class="string">    console.log(a.user); //xxx</span></span><br><span class="line"><span class="string">//new 的过程其实也是初始化了一个新的对象，然后用新的对象调用原先的函数 Fn.call(a) 这个情况跟下面这种情况类似了。</span></span><br></pre></td></tr></table></figure>

<p>apply, call, bind 通过改变函数的调用对象而改变 this 的指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id); <span class="comment">//42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;); <span class="comment">//foo函数的调用对象变成了 &#123;id: 42&#125;,所以this指向发生了变化</span></span><br></pre></td></tr></table></figure>

<p>箭头函数 this 的指向 —- this 指向其定义时候的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"peter"</span>;</span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  name: <span class="string">"tony"</span>,</span><br><span class="line">  c: (<span class="keyword">this</span>.name = <span class="string">"lily"</span>),</span><br><span class="line">  b: <span class="built_in">console</span>.log(<span class="string">"1"</span>, name), <span class="comment">//peter,函数里this指向global(node)/window ; 最先打印出</span></span><br><span class="line">  jiantou: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//若注解c: (this.name = "lily"),this === &#123;&#125;,指的定义处上下文;否则&#123;this.name = "lily"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//lily</span></span><br><span class="line">  &#125;,</span><br><span class="line">  putong: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">/* obj a &#123;</span></span><br><span class="line"><span class="comment">        name: 'tony',</span></span><br><span class="line"><span class="comment">        b: undefined,</span></span><br><span class="line"><span class="comment">        jiantou: [Function: jiantou],</span></span><br><span class="line"><span class="comment">        putong: [Function: putong]</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//tony</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.jiantou();</span><br><span class="line">a.putong();</span><br><span class="line"><span class="keyword">typeof</span> a.b; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的 this 在定义时所在的对象，其实质是因为箭头函数没有自己的 this,用的是外层的 this。<br>普通函数的 this 是看的是它执行时候的调用对象; 箭头函数的 this 与它的执行没有关系，在定义的时候就决定了。</p>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>this</title>
    <url>/2020/04/10/4.10/</url>
    <content><![CDATA[<ol>
<li>JSX 中使用三元运算符<br>{}大括号来在 JSX 中显示 JS 变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello &#123;this.props.someVar ? "World" : "Kitty"&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对象方法，”this”</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="comment">// "this" 指的是“当前的对象”; 可用 "user" 替代 "this"</span></span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">user.sayHi();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是 alert(user.name)，并且将 user 复制给另一个变量，例如 admin = user，并赋另外的值给 user，那么它将访问到错误的对象。</span></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line">user = <span class="literal">null</span>; <span class="comment">// 重写让其更明显</span></span><br><span class="line">admin.sayHi(); <span class="comment">// 噢哟！在 sayHi() 使用了旧的 name 属性！报错！</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>“this” 不受限制<br>this 可以用于任何函数，this 的值是在代码运行时计算出来的，它取决于代码上下文。 在没有对象的情况下调用：this == undefined 。</p>
</li>
<li><p>内部：引用类型<br>obj.method() 语句中有两个操作符。<br>首先，点符号 ‘.’ 取得这个 obj.method 属性。其后的括号 () 调用它。<br>如果把这些操作拆分开，那么 this 肯定会丢失：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  hi() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将赋值与方法调用拆分为两行</span></span><br><span class="line"><span class="keyword">let</span> hi = user.hi;</span><br><span class="line">hi(); <span class="comment">// 错误，因为 this 未定义</span></span><br></pre></td></tr></table></figure>

<p>这里 hi = user.hi 把函数赋值给变量，其后的最后一行代码是完全独立的，所以它没有 this。<br>为了让 user.hi() 有效，JavaScript 用了一个技巧 —— 这个 ‘.’ 点符号返回的不是一个函数，而是一种特殊的 引用类型 的值。<br>引用类型是一种“规范中有的类型”。我们不能明确地指定它，但它被用在编程语言的内部。<br>引用类型的值是三部分的结合 (base, name, strict)，如下：<br>base 是对象。<br>name 是属性名。<br>在严格模式 use strict 下，strict 为真。<br>属性访问 user.hi 的结果不是函数，而是引用类型。在严格模式下的 user.hi 是：<br>// 引用类型值<br>(user, “hi”, true)<br>括号 () 调用引用类型时，将接收关于该对象及其方法的所有信息，并且可以设定正确的 this 值（这里等于 user）。<br>引用类型是一种特殊的“中间”内部类型，用于将信息从点符号 . 传递到调用括号 ()。<br>像赋值 hi = user.hi 等其他的操作，将引用类型作为一个整体丢弃，只获取 user.hi（一个函数）的值进行传递。因此，任何进一步的操作都会“失去” this。</p>
<ol start="5">
<li>箭头函数没有自己的 “this”<br><a href="https://zh.javascript.info/arrow-functions#jian-tou-han-shu-mei-you-this" target="_blank" rel="noopener">箭头函数</a>没有 this。如果访问 this，则会从外部获取。</li>
</ol>
<p>6) 我的理解是：this 的传递需要对象+.+方法并且调用（）才能传递，否则会丢失。而且 this 是调用时给值，指向调用它的对象。</p>
]]></content>
      <tags>
        <tag>this</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>react官方文档</title>
    <url>/2020/04/14/4.14/</url>
    <content><![CDATA[<ol>
<li><p>事件监听函数后要加一个 function<br>onClick={() =&gt; alert(‘click’)<br>onClick={function() { alert(‘click’); }}</p>
</li>
<li><p>在类组件里，构造函数必须以 super(props) 开头。</p>
</li>
<li><p>状态提升<br>所有的 state 状态数据存储在父组件当中，之后父组件可以将这些数据通过 props 传递给各个子组件。遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。状态数据就能够更方便地同步共享。</p>
</li>
</ol>
<p>子组件不再持有 state，因此每次它们被点击的时候，子组件就会从父组件中接收值，并且通知父组件。在 React 术语中，我们把目前的 子组件称做“受控组件”。在这种情况下，父组件完全控制了子组件。</p>
<p>例子：Board 为父组件，Square 为子组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">renderSquare(i) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line"><span class="comment">//Board 把 whenClick=&#123;() =&gt; this.handleClick(i)&#125; 传递给了 Square，所以当 Square 中的事件处理函数触发时，其实就是触发的 Board 当中的 this.handleClick(i) 方法</span></span><br><span class="line">    &lt;Square</span><br><span class="line">    value=&#123;<span class="keyword">this</span>.state.squares[i]&#125;</span><br><span class="line">    whenClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick(i)&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"><span class="comment">//button 被点击时，React 会调用 Square 组件的 render() 方法中的 onClick 事件处理函数;事件处理函数触发了传入其中的 this.props.onClick() 方法</span></span><br><span class="line">            &lt;button</span><br><span class="line">            className=<span class="string">"square"</span></span><br><span class="line">            onClick=&#123;() =&gt; <span class="keyword">this</span>.props.whenClick()&#125; &gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.props.value&#125; &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>不可变性的优点？新数据替换旧数据，原变量值没改变<br>简化复杂的功能，撤销和恢复到之前的状态。<br>跟踪数据的改变，发现新的对象就可跟踪到改变。<br>确定在 React 中何时重新渲染，可以帮助我们在 React 中创建 pure components。</p>
</li>
<li><p>函数组件<br>函数接收 props 作为参数，然后返回需要渲染的元素。<br>写法简单，不用定义继承于 React.Component 的类，this.props 都替换成了 props。</p>
</li>
<li><p>实现“X” 和 “O” 轮流落子的效果</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">squares[i] = <span class="keyword">this</span>.state.xIsNext ? <span class="string">"X"</span> : <span class="string">"O"</span>;</span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  squares: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">  xIsNext: <span class="literal">true</span>, <span class="comment">//加一个 flag 判断</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/04/16/4.16/</url>
    <content><![CDATA[<ol>
<li><p>float 属性指定元素应如何浮动。<br>浮动元素之后的元素将在其周围流动<br>eg:比如<p>&lt;img ..float..&gt;</p></p>
<p>会在img周围流动
</li>
<li><p>网页上的每个元素都是一个矩形框。CSS 中的 display 属性确定矩形框的行为。<br>display: none<br>none 是 CSS 1 就提出来的属性，将元素设置为 none 的时候既不会占据空间，也无法显示，相当于该元素不存在。<br>display: inline<br>元素会占据最小的空间。任何高度和宽度属性均无效。<br>目前有很多原生的元素都是 inline 的，span、a、label、input、 img、 strong 和 em 就是典型的行内元素元素。default 是 inline 的。<br>display: block<br>元素会独占一行，即使宽度有剩余也会独占一行。<br>display: inline-block<br>inline-block 既具有 block 的宽高特性又具有 inline 的同行元素特性。可以设置高度和宽度。</p>
</li>
<li><p>为什么会出现<a href="https://www.html.cn/archives/8629" target="_blank" rel="noopener">flex</a>以及解决了什么？<br>为了提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。<br>Flex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间（主要是为了适应所有类型的显示设备和屏幕尺寸）。flex 布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。<br>相比于常规布局（基于垂直的块（block）和基于水平的内联（inline）， 虽然传统布局适用于页面，但它们对于大型或复杂的应用程序布局来说缺乏灵活性（特别是在改变方向，调整大小，拉伸，收缩等方面），flex 布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>css float</tag>
        <tag>css flex</tag>
      </tags>
  </entry>
  <entry>
    <title>weather projrct</title>
    <url>/2020/04/17/4.17/</url>
    <content><![CDATA[<ol>
<li>使用 heroku 更新内容</li>
</ol>
<ul>
<li>git status 看改变</li>
<li>git add</li>
<li>git commit -m</li>
<li>git pull</li>
<li>git push push 到远端</li>
<li>heroku login</li>
<li>git push heroku master 重新部署</li>
</ul>
<ol start="2">
<li><p>weather-project 项目结构<br><a href="https://github.com/kyrie96521/weather-website">github repo</a><br>技术栈 node，hbs 视图</p>
</li>
<li><p>主要项目流程<br>当用户输入地点时，监听 submit 事件并传入回调，在 js 文件夹里的 app.js 会 fetch 用户输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="regexp">/weather?address= + location).then(response =&gt; &#123;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>在根目录的之后 app.get(/weather, (req, res) =&gt; {})响应，根据地点来调用 forecast.js 和 geocode.js, 并通过 res.send({})（服务器端返回数据到客户）返回一个 json 格式的数据给 app.js。<br>之后 then 用 response 来获得数据并操作 dom 来渲染在页面上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="regexp">/weather?address= + location).then(response =&gt; &#123;</span></span><br><span class="line"><span class="regexp">response.json().then(data =&gt; &#123;</span></span><br><span class="line"><span class="regexp">console.log(data);</span></span><br><span class="line"><span class="regexp">if (data.error) &#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/console.log(data.error);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/能够显示在 DOM 里</span></span><br><span class="line"><span class="regexp">messageOne.textContent = data.error;</span></span><br><span class="line"><span class="regexp">&#125;else &#123;</span></span><br><span class="line"><span class="regexp">messageOne.textContent = data.location;</span></span><br><span class="line"><span class="regexp">messageTwo.textContent = data.forcast;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>项目难点<br>fetch endpoint 等待搜索结果时间，then 里传入回调函数 response 异步获取资源<br>fetch(url).then(function(response===res.send)</p>
<p>等待 request api 时间过后，传入回调函数作为参数传进 forecast.js 来获取数据，注意异步。<br>项目流程逻辑以及回调函数。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb</title>
    <url>/2020/04/02/4.2/</url>
    <content><![CDATA[<ol>
<li>mongoose.Schema<br>schema 就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等。在 Mongoose 中，一切都被 Schema 所驱动。<br>在下面程序中，我们定义了一个 UserSchema，这个 UserSchema 对应在 mongoDB 中是一个 UserSchema 集合。该集合有两个属性，一个是 name，类型为 string，另一个是 email，类型也是 string。<br>在 Mongoose 中，所有数据都由一个 Schema 开始创建。每一个 schema 都映射到一个 Mongodb 的集合(collection)，并定义了该集合(collection)中的文档(document)的形式。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  email: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    unique: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>理解中间件：<br>将具体业务和底层逻辑解耦的组件，解耦指的是各部分相互独立，也可以通过接口相匹配。<br>大致的效果是：需要利用服务的人（前端写业务的），不需要知道底层逻辑（提供服务的）的具体实现，只要拿着中间件结果来用就好了。<br>express 里的中间件指的在处理请求和发送响应之间的方法/功能/操作。</p>
</li>
<li><p>body-parser 中间件<br>body-parser 是一个 HTTP 请求体解析中间件，使用这个模块可以解析 JSON、Raw、文本、URL-encoded 格式的请求体，Express 框架中就是使用这个模块做为请求体解析中间件。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.json(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>返回一个仅解析 json 格式数据的中间件，并且让我们通过 req.body 得到 data</p>
<ol start="4">
<li>express-validator 中间件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; check, validationResult &#125; = <span class="built_in">require</span>(<span class="string">"express-validator/check"</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/huruji/blog/issues/21">check</a>，判断合法性等方法。</p>
<ol start="5">
<li><p>HTTP<br>http headers 里的：<br>Content-Type 标头用于指示资源的媒体类型。媒体类型是与文件一起发送的字符串，指示文件的格式。例如，对于图像文件，其媒体类型将为 png 或 jpg 等.</p>
<p>状态码：<br>200 OK 请求成功。一般用于 GET 与 POST 请求<br>201 Created 已创建。成功请求并创建了新的资源<br>400 Bad Request 客户端请求的语法错误，服务器无法理解<br>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求<br>404 Not Found 服务器无法根据客户端的请求找到资源（网页）<br>500 Internal Server Error 服务器内部错误，无法完成请求</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000016788484" target="_blank" rel="noopener">aysnc-await</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">json web token</a><br>互联网服务一般流程是下面这样:<br>1、用户向服务器发送用户名和密码。<br>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。<br>3、服务器向用户返回一个 session_id，写入用户的 Cookie。<br>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。<br>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。<br>JWT 的方案是服务器不保存 session 数据，所有数据都保存在客户端，每次请求都发回服务器。JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，每当用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。<br><img src="/images/jwt.jpg" alt=""></p>
</li>
<li><p>config.get() 使用 config 来管理配置文件</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">config.get(<span class="string">"jwtSecret"</span>); <span class="comment">//jwtSecret 在配置文件里。</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在服务器里 entrypt password</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>);</span><br><span class="line">user.password = <span class="keyword">await</span> bcrypt.hash(passwork, salt);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>异步原理：<br>js 是单线程，意味着排队执行，如果计算量大，cpu 会忙不过来。设计者意识到主线程完全可以不管 io 阻塞，挂起处于等待中的任务，先运行排在后面的任务，等到 io 阻塞返回了结果，再把挂起的任务执行下去。</li>
</ol>
]]></content>
      <tags>
        <tag>this</tag>
        <tag>mongodb</tag>
        <tag>middleware</tag>
        <tag>http</tag>
        <tag>aysnc</tag>
        <tag>异步</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>react lifecycle</title>
    <url>/2020/04/23/4.23/</url>
    <content><![CDATA[<p>众所周知，这个世界上的所有事物都遵循一个周期（例如人类或树木）。我们出生，成长，然后死亡。几乎所有事物都遵循其生命周期，React 组件也是如此。组件被创建（mount 安装在 DOM 上），通过更新而增长，然后消失（在 DOM 上卸载 unmount）。这称为组件生命周期。</p>
<ol>
<li><p>初始化 initialize<br>在这个阶段，组件将通过 setting state 和 prop 来开始。这通常是在 constructor method 构造方法中完成的。</p>
</li>
<li><p>安装 mounting<br>mounting 是我们的 React 组件在 DOM 上挂载的阶段（即创建并插入到 DOM 中）。初始化阶段完成后，此阶段开始。在此阶段，我们的组件将首次呈现。此阶段可用的方法是：</p>
</li>
</ol>
<p>componentWillMount（）在组件安装在 DOM 上或调用 render 方法之前，将调用此方法。使用此方法后，将安装组件。注意：请勿在此方法中使用 this.setstate 进行 API 调用或任何数据更改，因为它是在 render 方法之前调用的。因此，由于 DOM 尚未挂载，因此无法对其进行任何处理（即使用 API??响应更新数据）。因此，我们无法使用 API??响应来更新状态。</p>
<p>componentDidMount（）在组件安装到 DOM 后，将调用此方法。<br>与 componentWillMount 一样，它在生命周期中被调用一次。在执行此方法之前，将调用 render 方法（即，我们可以访问 DOM）。我们可以进行 API 调用，并使用 API??响应更新状态。</p>
<ol start="3">
<li>更新 updating<br>这是我们组件通过的第三阶段。在已创建组件的安装阶段之后，进入了更新阶段。这是组件状态改变的地方，因此，进行了重新渲染。在此阶段，组件的数据（state 和 prop）会根据用户事件（例如单击，键入等）进行更新。这导致组件的重新渲染。此阶段可用的方法是：</li>
</ol>
<p>shouldComponentUpdate（）此方法确定是否应更新组件。<br>默认情况下，它返回 true。但是在某些时候，如果您想在某种条件下重新渲染组件，则应该使用 componentComponentUpdate 方法。例如，假设您只想在 prop 发生更改时重新渲染组件，然后利用此方法的强大功能。它接收诸如 nextProps 和 nextState 之类的参数，这些参数可以帮助我们通过与当前 prop 值进行比较来决定是否重新渲染。</p>
<p>componentWillUpdate（）重新渲染组件之前调用它。在“ shouldComponentUpdate”方法之后调用一次。如果要在重新渲染组件之前以及在更新状态和属性之后执行一些计算，那么这是执行此操作的最佳位置。就像“ shouldComponentUpdate”方法一样，它也接收诸如 nextProps 和 nextState 之类的参数。</p>
<p>ComponentDidUpdate（）在重新渲染组件之后立即调用此方法。在新的（更新的）组件在 DOM 上更新后，将执行“ componentDidUpdate”方法。此方法接收诸如 prevProps 和 prevState 之类的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    date : <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    clickedStatus: <span class="literal">false</span>,</span><br><span class="line">    list:[]</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Component will mount!)</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Component did mount!)</span><br><span class="line">    <span class="keyword">this</span>.getList();</span><br><span class="line">&#125;</span><br><span class="line">getList=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/*** method to make api call***/</span></span><br><span class="line">    fetch(https:<span class="comment">//api.mydomain.com)</span></span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">list</span>:data &#125;));</span><br><span class="line">&#125;</span><br><span class="line">shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.list!==nextState.list</span><br><span class="line">&#125;</span><br><span class="line">componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Component will update!);</span><br><span class="line">&#125;</span><br><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Component did update!)</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;Hello Mounting Lifecycle Methods!&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>卸载<br>这是组件生命周期的最后一个阶段。顾名思义，该阶段将组件从 DOM 卸载。此阶段可用的方法是：<br>componentWillUnmount（）在卸载组件之前会调用此方法。在从 DOM 中删除组件之前，执行“ componentWillUnMount”。此方法表示组件生命周期的结束。</p>
</li>
<li><p><img src="/images/reactlife.jpg" alt=""></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>sass</title>
    <url>/2020/04/18/4.18/</url>
    <content><![CDATA[<ol>
<li><p>CSS 预处理器：用一种专门的编程语言，进行网页样式设计，然后再编译成正常的 CSS 文件</p>
</li>
<li><p>嵌套<br>在嵌套的代码块内，可以使用&amp;引用父元素。比如 a:hover 伪类</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   　　 <span class="selector-tag">a</span> &#123;</span><br><span class="line">   　　　　&amp;:hover &#123; color: #ffb3ff; &#125;</span><br><span class="line">   　 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   　　<span class="selector-class">.class1</span> &#123;</span><br><span class="line">   　　　　 <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">   　　&#125;</span><br><span class="line">   　　<span class="selector-class">.class2</span> &#123;</span><br><span class="line">   　　　　@extend .class1;</span><br><span class="line">   　　　　 <span class="selector-tag">font-size</span><span class="selector-pseudo">:120</span>%;</span><br><span class="line">   　　&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mixin 可以重用的代码块<br>mixin 可以指定参数和缺省值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">@mixin</span> left($<span class="attribute">value:</span> <span class="number">10px</span>) &#123;</span><br><span class="line">　<span class="selector-tag">float</span>: <span class="selector-tag">left</span>;</span><br><span class="line">　margin-right: $value;</span><br><span class="line">　　&#125;</span><br><span class="line">使用的时候，根据需要加入参数：</span><br><span class="line">　　 <span class="selector-tag">div</span> &#123;</span><br><span class="line">　　　　@include left(20px);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件、循环语句<br><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/sass.html</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>html&amp;js</title>
    <url>/2020/04/05/4.5/</url>
    <content><![CDATA[<ol>
<li><p>setTimeout()、setInterval()的区别在于？<br>setTimeout()：当方法执行完成定时器就立即停止(但是定时器还在,只不过没用了);<br>setInterval()：当方法执行完成,定时器并没有停止,以后每隔[interval]这么长的时间都会重新的执行对应的方法[function],直到我们手动清除定时器为止;</p>
</li>
<li><p>什么 HTML 结构的语义化？<br>我的理解是让每个标签具有意义而不是无意义的标签 div 和 span；<br>为什么要语义化?<br>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构；用户体验；有利于 SEO（搜索引擎优化）；便于团队开发和维护，语义化更具可读性，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。</p>
</li>
<li><p><a href="https://blog.csdn.net/major_zhang/article/details/79154287" target="_blank" rel="noopener">Promise 和 async-await 理解</a></p>
</li>
<li><p>JSX 最终会被 babel 编译为合法的 JS 语句给 React.createElement()函数调用（编译器在遇到{时采用 JS 语法进行解析，遇到&lt;就采用 HTML 规则进行解析）</p>
</li>
<li><p>label 标签</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;label&gt; 标签的 <span class="keyword">for</span> 属性应当与相关元素（input）的 id 属性相同。</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"jog"</span>&gt;慢跑&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="checkbox" name="jog" id="jog" /</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>this</tag>
        <tag>promise</tag>
        <tag>sql</tag>
        <tag>js</tag>
        <tag>html</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title>react this keyword</title>
    <url>/2020/04/04/4.4/</url>
    <content><![CDATA[<ol>
<li><p>SQL 中 join 操作后面的 on 与 where 的区别<br>得到 on 条件是在 left join 之前先进行条件筛选，而后才对两个表格 join 操作，on 比 where 起作用更早，先根据 on 条件进行多表的连接操作，生成一个临时表再通过 where 来筛选</p>
</li>
<li><p>react 什么时候 render？<br>如果父组件重新渲染，则会发生重新渲染（可能包括新道具）<br>如果调用 this.setState（），将安排重新渲染。</p>
</li>
<li><p>function 的三种类型<br>构造函数：是用于使用 new 关键字创建具有相同原型的新对象的函数</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"amitai"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name); <span class="comment">// ‘amitai’this === newPerson</span></span><br><span class="line"><span class="comment">//我们使用它来设置 Person 的实例。调用构造函数时，this.name 的值为“ amitai”。并且对象 newPerson 具有值为 amitai 的属性名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数：如果函数不是对象的属性，则它是“普通函数”。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined in “strict mode” or the global variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：方法是一个定义为对象属性的函数。</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.firstName = <span class="string">"Amitai"</span>;</span><br><span class="line">person.lastName = <span class="string">"Barnea"</span>; <span class="comment">// 在方法里，this 用于引用对象的其他属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName()); <span class="comment">// ‘Amitai Barnea’</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象方法和内嵌函数的 this 指向</span></span><br><span class="line"><span class="comment">//与变量不同，this 关键字没有作用域，并且嵌套函数不继承其调用者的 this 值,会被当做为普通函数指向 window/global。</span></span><br><span class="line"><span class="comment">//如果将嵌套函数作为方法调用，则其 this 值为在其上调用的对象.</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//person</span></span><br><span class="line">    <span class="keyword">var</span> calcFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window/global</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//把返回值换成 this.firstName + " " + this.lastName 会正常打印</span></span><br><span class="line">    <span class="keyword">return</span> calcFullName();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.firstName = <span class="string">"Amitai"</span>;</span><br><span class="line">person.lastName = <span class="string">"Barnea"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.fullName()); <span class="comment">// Undefined!!!</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>react 怎么操作 dom？<br>大部分情况下你不需要去操作 DOM 元素，你只需要通过设置组件的状态值（setState），react 会通过状态值去渲染组 UI。但是可能在某些情况下你确实需要直接操作 DOM。<br>react 是从 jsx 到虚拟 dom 再从虚拟 dom 生成 dom 的，所以需要在页面生成 DOM 后才能去操作 DOM 节点的，那么很容易让我们相到 react 的几个生命周期，componentDidMount（）就是在组件挂载之后调用的一个生命周期，这时已经生成了 DOM 节点，所以，可以在这个生命周期里 操作 DOM！</p>
</li>
<li><p>为什么在 componentWillReceiveProps 在中调用 this.setState() 将不会引起第二次渲染？如果不重新渲染，那么获取到的新数据怎么更新到视图上去？</p>
</li>
</ol>
<p>props 有两种调用方式，第一，直接使用<br>这种方式，父组件改变 props 后，子组件重新渲染，由于直接使用的 props，所以我们不需要做什么就可以正常显示最新的 props</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someThings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二、转换成自己的 state<br>由于我们使用的是 state，所以每当父组件每次重新传递 props 时，我们需要重新处理下，将 props 转换成自己的 state，这里就用到了 componentWillReceiveProps。为什么不会二次渲染是这样的：每次子组件接收到新的 props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的 props 更新 state，更新 state 也会触发一次重新渲染，但 react 不会这么傻，所以只会渲染一次，这对应用的性能是有利的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      someThings: props.someThings,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">someThings</span>: nextProps.someThings &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.someThings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>this</tag>
        <tag>dom</tag>
        <tag>sql</tag>
        <tag>lifecycle</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>express路由</title>
    <url>/2020/04/06/4.6/</url>
    <content><![CDATA[<ol>
<li><p>路由<br>路由表示应用程序端点 (URI) 的定义以及端点响应客户机请求的方式。</p>
</li>
<li><p>路由方法<br>路由方法派生自 HTTP 方法之一，附加到 express 类的实例</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST method route</span></span><br><span class="line">app.post(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">"POST request to the homepage"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">"/secret"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Accessing the secret section ..."</span>);</span><br><span class="line">  next(); <span class="comment">// pass control to the next handler</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>路由路径<br>路由路径与请求方法相结合，用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。<br>此路由路径将匹配 /abe 和 /abcde。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/ab(cd)?e"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">"ab(cd)?e"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>路由处理程序<br>可以提供多个回调函数，以类似于中间件的行为方式来处理请求，这些回调函数可能调用 next(“route”) 来绕过剩余的路由回，路由处理程序的形式可以是一个函数、一组函数或者两者的结合。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"CB0"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"CB1"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.get(</span><br><span class="line">  <span class="string">"/example/d"</span>,</span><br><span class="line">  [cb0, cb1],</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"the response will be sent by the next function ..."</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"Hello from D!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5.app.route()<br>使用 app.route() 为路由路径创建可链接的路由处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .route(<span class="string">"/book"</span>)</span><br><span class="line">  .get(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"Get a random book"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"Add a book"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">"Update the book"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>6.express.Router<br>使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。<br>以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。<br>在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// middleware that is specific to this router</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timeLog</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Time: "</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// define the home page route</span></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">"Birds home page"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// define the about route</span></span><br><span class="line">router.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">"About birds"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br><span class="line"><span class="comment">//接着，在应用程序中装入路由器模块：</span></span><br><span class="line"><span class="keyword">var</span> birds = <span class="built_in">require</span>(<span class="string">"./birds"</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/birds"</span>, birds);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>CICD</title>
    <url>/2020/04/02/4.3/</url>
    <content><![CDATA[<h3 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a><a href="https://blog.jjonline.cn/linux/238.html" target="_blank" rel="noopener">CICD</a></h3><p>CI 的英文名称是 Continuous Integration，中文翻译为：持续集成。<br>CI 中，开发人员将会频繁地向主干提交代码，这些新提交的代码在最终合并到主干前，需要经过编译和自动化测试流进行验证。</p>
<p>持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程。持续集成的目标是快速确保开发人员新提交的变更是好的，并且适合在代码库中进一步使用。CI 的流程执行和理论实践让我们可以确定新代码和原有代码能否正确地集成在一起。</p>
<p>CD 可对应多个英文名称，持续交付 Continuous Delivery 和持续部署 Continuous Deployment 。<br>持续交付<br>完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。<br>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中或发布给最终使用的用户。<br><img src="/images/ci.png" alt=""><br>持续部署<br>对于一个成熟的 CI/CD 管道（Pipeline）来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。<br>持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。<br>持续交付并不是指软件每一个改动都要尽快部署到产品环境中，它指的是任何的代码修改都可以在任何时候实施部署。<br>持续交付表示的是一种能力，而持续部署表示的则一种方式。持续部署是持续交付的最高阶段<br><img src="/images/cd.png" alt=""></p>
]]></content>
      <tags>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript语法</title>
    <url>/2020/05/19/5.19/</url>
    <content><![CDATA[<h1 id="Javascript-Adavanced"><a href="#Javascript-Adavanced" class="headerlink" title="Javascript Adavanced"></a>Javascript Adavanced</h1><p>** OOP **</p>
<p>encapsulation 封装性，将属性和方法放在同一对象里。<br>abstraction 抽象性，简易接口，减少改变的影响。<br>inheritance 继承性，减少重用代码。<br>polymorphism 多态性。</p>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="1-创建对象的两种方式"><a href="#1-创建对象的两种方式" class="headerlink" title="1. 创建对象的两种方式"></a>1. 创建对象的两种方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// factory function</span></span><br><span class="line"><span class="comment">// 当创建多个的对象时，使用factory函数返回一个对象, 减少重用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    radius,</span><br><span class="line">    draw: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"draw2"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle2 = createCircle(<span class="number">2</span>);</span><br><span class="line">circle2.draw();</span><br><span class="line"></span><br><span class="line"><span class="comment">// construction function</span></span><br><span class="line"><span class="comment">// 用this来代替调用者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this 代指那个对象，对对象设置属性，而非返回一个对象。指向调用者。</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new操作符会有三步</span></span><br><span class="line"><span class="comment">// 1.new操作符会创建一个空的对象 2.并把this指向这个对象，this默认指向global/window</span></span><br><span class="line"><span class="comment">// 3.返回这个对象，不用return</span></span><br><span class="line"><span class="keyword">const</span> constructor1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-constructor-属性"><a href="#2-constructor-属性" class="headerlink" title="2. constructor 属性"></a>2. constructor 属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印出function Object</span></span><br><span class="line"><span class="comment">// 原因是当时用let x = &#123;&#125;来构造函数时，内部是调用let x = new Object()来构造的</span></span><br><span class="line"><span class="comment">// String()，Boolean()也相同</span></span><br><span class="line"><span class="built_in">console</span>.log(circle.constructor);</span><br><span class="line"><span class="comment">// 打印出function Circle</span></span><br><span class="line"><span class="built_in">console</span>.log(constructor1.constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 也是对象，所以也可使用constructor属性，会得到Function 等同于如下。</span></span><br><span class="line"><span class="keyword">const</span> Circle = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">"radius"</span>,</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">    this.radius = radius;</span></span><br><span class="line"><span class="string">    this.draw = function()&#123;</span></span><br><span class="line"><span class="string">        console.log("draw")</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// (object:target of this, argument)</span></span><br><span class="line">Circle.call(&#123;&#125;, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// arguments in array</span></span><br><span class="line">Circle.apply(&#123;&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-数据类型以及原理"><a href="#3-数据类型以及原理" class="headerlink" title="3. 数据类型以及原理"></a>3. 数据类型以及原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// value type(primitive type): number string beeloean symbol undefined null</span></span><br><span class="line"><span class="comment">// reference type: object function array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">value</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// &#123;value : 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>原因是 reference type 的值存在 memory 里，变量是引用其地址。<br>当执行 let y = x 时， y 保存的也是{value : 20}的地址。但对于原始值类型，x 值改变，y 值不会变。<br>primitives are copied by their value, objects are copied by there reference</p>
<h3 id="4-增加，删除，遍历属性或方法"><a href="#4-增加，删除，遍历属性或方法" class="headerlink" title="4. 增加，删除，遍历属性或方法"></a>4. 增加，删除，遍历属性或方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象可以直接加或者删除属性或者方法</span></span><br><span class="line">circle.location = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">circle[<span class="string">"location"</span>] = &#123; <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> [circle.location];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象的属性和值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> circle) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> circle[key] !== <span class="string">"function"</span>) <span class="built_in">console</span>.log(key, circle[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到keys</span></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(Circle);</span><br><span class="line"><span class="built_in">console</span>.log(keys);</span><br></pre></td></tr></table></figure>

<h3 id="5-闭包，getter-amp-setter-函数"><a href="#5-闭包，getter-amp-setter-函数" class="headerlink" title="5. 闭包，getter&amp;setter 函数"></a>5. 闭包，getter&amp;setter 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="comment">// private object inside constructor function</span></span><br><span class="line">  <span class="keyword">let</span> defaultlocation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> defaultlocationpos = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x, y;</span><br><span class="line">    defaultlocation(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter：读取属性的函数</span></span><br><span class="line">  <span class="comment">// setter：更改属性值的函数</span></span><br><span class="line">  <span class="comment">// (要加属性的object，属性的名字,get function)</span></span><br><span class="line">  <span class="comment">// defaultlocationpos是闭包，这样就可以被外部访问</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">"defaultlocationpos"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> defaultlocationpos;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 参数值是value 可进行validation check.</span></span><br><span class="line">    <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">      defaultlocation = value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line">circle.defaultlocationpos;</span><br><span class="line">circle.defaultlocationpos = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>抽象性的理解：hide the details, show the essentials<br>闭包和作用域：<br>一个函数在另一个函数里，里面的函数可以定义一些变量，但里函数执行结束后就会被垃圾回收 dies。<br>里函数可访问的变量：函数内定义的以及父级作用域。每次里函数被调用时，它重新激活并且被回收。<br>所以 scope{}是暂时的，但 closure 是永久的。<br>因为会作用到父级作用域的对象(defaultlocationpos)里(我们知道 object 可被在函数里改变)。</p>
<h2 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h2><h3 id="1-继承性"><a href="#1-继承性" class="headerlink" title="1. 继承性"></a>1. 继承性</h3><p>prototype 可以想象成父级对象。<br>每一个对象都有 prototype，除了 objectBase(root object)。<br>x.proto 里的所有函数都是继承而来，但 x.proto 这种写法已经被弃用，使用 Object.getPrototypeOf(x)来获取父级继承函数。<br>当在对象里找不到函数时，js 会向上通过原型链不断寻找该函数。prototype 只是一个对象，里面涵盖了可被继承的所有方法。</p>
<h3 id="2-多层继承"><a href="#2-多层继承" class="headerlink" title="2. 多层继承"></a>2. 多层继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [];</span><br></pre></td></tr></table></figure>

<p>我们发现 myArray 第一层的 proto 是 arrayBase 对象，里面包含了所有 array 方法，并且 myArray 源自(derive from)rrayBase 对象这个 prototype。我们在这一层又发现了一个 proto，第二层里面是 objectBase 的方法，这就是多层继承。<br>circle 的第一层 proto 是构造函数，这是因为所有 new 操作出来的实例都是继承了构造函数的属性方法。<br>第二层是 objectBase。</p>
<h3 id="3-属性描述符"><a href="#3-属性描述符" class="headerlink" title="3. 属性描述符"></a>3. 属性描述符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">"mosh"</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> objectBase = <span class="built_in">Object</span>.getPrototypeOf(person)</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(objectBase, <span class="string">"toString"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> &#123;writable: true, enumerable: false, configurable: true, value: ƒ&#125;</span></span><br><span class="line"><span class="comment"> configurable: true 是否可以删除属性</span></span><br><span class="line"><span class="comment"> enumerable: false 直接遍历实例对象</span></span><br><span class="line"><span class="comment"> value: ƒ toString() 默认值</span></span><br><span class="line"><span class="comment"> writable: true 是否可以重写</span></span><br><span class="line"><span class="comment"> __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新给对象定义属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        writable: <span class="literal">false</span>, <span class="comment">// 不能重写 &#123;name: "mosh"&#125;</span></span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// 不会在objects.keys()实例对象里出现</span></span><br><span class="line">  configureable：<span class="literal">false</span> <span class="comment">// 不可改变</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">person.name = <span class="string">"john"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>

<p>得到原型/父级的属性描述。</p>
<h3 id="4-构造函数原型"><a href="#4-构造函数原型" class="headerlink" title="4. 构造函数原型"></a>4. 构造函数原型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">"mosh"</span>&#125;;</span><br><span class="line">person.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(person)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">person.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对象实例.<strong><em>proto</em></strong> = 它的构造函数.prototype</p>
<h3 id="5-在-prototype-里增加方法或属性"><a href="#5-在-prototype-里增加方法或属性" class="headerlink" title="5. 在 prototype 里增加方法或属性"></a>5. 在 prototype 里增加方法或属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//instance member</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="comment">// 并且在实例里可以用prototype定义的方法</span></span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.move();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Circle &#123;radius: 1, draw: ƒ&#125;</span></span><br><span class="line"><span class="comment"> draw: ƒ ()</span></span><br><span class="line"><span class="comment"> radius: 1</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">  constructor: ƒ Circle(radius)</span></span><br><span class="line"><span class="comment">  __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototype members</span></span><br><span class="line"><span class="comment">// 可把draw方法定义道prototype里面</span></span><br><span class="line"><span class="comment">// js引擎会一直向下一层寻找这个方法</span></span><br><span class="line"><span class="comment">// 并且在prototype可以用实力里定义的方法</span></span><br><span class="line">Circle.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.draw();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"move"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Circle &#123;radius: 1, draw: ƒ&#125;</span></span><br><span class="line"><span class="comment"> radius: 1</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">  move: ƒ ()</span></span><br><span class="line"><span class="comment">  constructor: ƒ Circle(radius)</span></span><br><span class="line"><span class="comment">  __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="6-遍历实例和原型-members"><a href="#6-遍历实例和原型-members" class="headerlink" title="6. 遍历实例和原型 members"></a>6. 遍历实例和原型 members</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能遍历实例里的属性方法</span></span><br><span class="line"><span class="comment">// ["radius", "draw"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(c1);</span><br><span class="line"><span class="comment">// 遍历实例和原型所有的属性方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> c1) <span class="built_in">console</span>.log(key);</span><br><span class="line"><span class="comment">// 判断是否是实例的方法</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">c1.hasOwnProperty(<span class="string">"move"</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">c1.hasOwnProperty(<span class="string">"draw"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Prototypical-Inheritance"><a href="#Prototypical-Inheritance" class="headerlink" title="Prototypical Inheritance"></a>Prototypical Inheritance</h2><h3 id="创建原型继承"><a href="#创建原型继承" class="headerlink" title="创建原型继承"></a>创建原型继承</h3><p>处理重复代码问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"duplicate"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius, color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// shape 是函数也是对象，用call改变this指向。实例c能使用Shape属性。</span></span><br><span class="line">  shape.call(<span class="keyword">this</span>, color);</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认是Object.prototype</span></span><br><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// 创建了一个继承于shapeBase的原型，并令circlebase继承于shapebase</span></span><br><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"><span class="comment">// 但每次重新设置继承关系时，被设置的构造函数Circle会丢失之前的构造函数，指向继承的构造函数。</span></span><br><span class="line"><span class="comment">// 所以我们需要再重新设置为之前的构造函数</span></span><br><span class="line">Circle.prototype.constructor = Circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 令Square也继承于Shape</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Square.prototype.constructor = Square;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承代码冗余，用function代替；代替上述行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">  Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">  Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Shape(<span class="string">"red"</span>);</span><br><span class="line"><span class="keyword">const</span> sq = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Circle &#123;radius: 1, draw: ƒ&#125;</span></span><br><span class="line"><span class="comment"> draw: ƒ ()</span></span><br><span class="line"><span class="comment"> radius: 1</span></span><br><span class="line"><span class="comment"> __proto__: Shape</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>c 继承于 Circle.prototype(circleBase), circleBase 继承 objectBase。s 亦然。</p>
<h3 id="重新定义继承的-prototype-属性或方法"><a href="#重新定义继承的-prototype-属性或方法" class="headerlink" title="重新定义继承的 prototype 属性或方法"></a>重新定义继承的 prototype 属性或方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"duplicate circle"</span>); <span class="comment">//duplicate circle</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 强制先执行继承的Shape</span></span><br><span class="line">  Shape.prototype.deplicate.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"duplicate circle"</span>);</span><br><span class="line">  <span class="comment">/** duplicate</span></span><br><span class="line"><span class="comment">   duplicate circle</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">c.duplicate();</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>js 引擎根据原型链找到第一个方法实现就中止</p>
<h3 id="多态性-polymorphism"><a href="#多态性-polymorphism" class="headerlink" title="多态性 polymorphism"></a>多态性 polymorphism</h3><p>有多种不同的重新定义后的继承方法，这就是多态性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将其他对象里的方法或属性加入到一个新对象中</span></span><br><span class="line"><span class="keyword">const</span> newObject = <span class="built_in">Object</span>.assign(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  methodPropertyOfoneObject,</span><br><span class="line">  methodPropertyOfoneObject</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="1-Classes"><a href="#1-Classes" class="headerlink" title="1. Classes"></a>1. Classes</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// instance method</span></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"draw"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static method</span></span><br><span class="line">  <span class="keyword">static</span> parse(str) &#123;</span><br><span class="line">    <span class="keyword">const</span> radius = <span class="built_in">JSON</span>.parse(str).radius;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Circle1(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Circle1); <span class="comment">// funciton</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法不对实例c1使用，而对Circle class使用。返回一个Circle对象</span></span><br><span class="line"><span class="keyword">const</span> c2 = Circle.parse(<span class="string">"&#123;'radius':1&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Circle1 &#123;radius: 1, move: ƒ&#125;</span></span><br><span class="line"><span class="comment"> move: ƒ ()</span></span><br><span class="line"><span class="comment"> radius: 1</span></span><br><span class="line"><span class="comment"> __proto__:</span></span><br><span class="line"><span class="comment">  constructor: class Circle1</span></span><br><span class="line"><span class="comment">  draw: ƒ draw()</span></span><br><span class="line"><span class="comment">  __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Hoisting-hoisted"><a href="#2-Hoisting-hoisted" class="headerlink" title="2. Hoisting/hoisted"></a>2. Hoisting/hoisted</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function declaration is hoisted and is raised to top of the code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function expression is not hoisted</span></span><br><span class="line"><span class="keyword">const</span> sayGoodbye = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class declaration is not hoisted</span></span><br></pre></td></tr></table></figure>

<h3 id="3-this-keyword"><a href="#3-this-keyword" class="headerlink" title="3. this keyword"></a>3. this keyword</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Circle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Circle();</span><br><span class="line"><span class="comment">// method call (c1)</span></span><br><span class="line">c1.draw();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> draw = c1.draw;</span><br><span class="line"><span class="comment">// function call reference (window);use strict 情况下undefined</span></span><br><span class="line">draw();</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 情况下默认是strict模式</span></span><br></pre></td></tr></table></figure>

<h3 id="4-private-members-in-class"><a href="#4-private-members-in-class" class="headerlink" title="4. private members in class"></a>4. private members in class</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了隐藏一些属性对函数或者类外</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个唯一的值，不能直接访问这个属性</span></span><br><span class="line"><span class="keyword">const</span> _radius = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    <span class="keyword">this</span>[_radius] = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  [_draw]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
