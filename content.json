{"meta":{"title":"Kyle's Blog","subtitle":"","description":"","author":"Kyle Yang","url":"https://github.com/kyrie96521/kyrie96521.github.io","root":"/"},"pages":[{"title":"Tags","date":"2020-03-03T04:17:46.000Z","updated":"2020-03-04T00:44:53.835Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-03T08:30:00.000Z","updated":"2020-03-07T07:12:23.140Z","comments":true,"path":"about/index.html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/about/index.html","excerpt":"","text":"Record the leaning process of Kyle"}],"posts":[{"title":"express路由","slug":"4.6","date":"2020-04-05T15:23:48.000Z","updated":"2020-04-06T05:14:57.058Z","comments":true,"path":"2020/04/06/4.6/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/04/06/4.6/","excerpt":"","text":"路由路由表示应用程序端点 (URI) 的定义以及端点响应客户机请求的方式。 路由方法路由方法派生自 HTTP 方法之一，附加到 express 类的实例 1234// POST method routeapp.post(\"/\", function (req, res) &#123; res.send(\"POST request to the homepage\");&#125;); 有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。 1234app.all(\"/secret\", function (req, res, next) &#123; console.log(\"Accessing the secret section ...\"); next(); // pass control to the next handler&#125;); 路由路径路由路径与请求方法相结合，用于定义可以在其中提出请求的端点。路由路径可以是字符串、字符串模式或正则表达式。此路由路径将匹配 /abe 和 /abcde。 123app.get(\"/ab(cd)?e\", function (req, res) &#123; res.send(\"ab(cd)?e\");&#125;); 路由处理程序可以提供多个回调函数，以类似于中间件的行为方式来处理请求，这些回调函数可能调用 next(“route”) 来绕过剩余的路由回，路由处理程序的形式可以是一个函数、一组函数或者两者的结合。 123456789101112131415161718192021var cb0 = function (req, res, next) &#123; console.log(\"CB0\"); next();&#125;;var cb1 = function (req, res, next) &#123; console.log(\"CB1\"); next();&#125;;app.get( \"/example/d\", [cb0, cb1], function (req, res, next) &#123; console.log(\"the response will be sent by the next function ...\"); next(); &#125;, function (req, res) &#123; res.send(\"Hello from D!\"); &#125;); 5.app.route()使用 app.route() 为路由路径创建可链接的路由处理程序。 1234567891011app .route(\"/book\") .get(function (req, res) &#123; res.send(\"Get a random book\"); &#125;) .post(function (req, res) &#123; res.send(\"Add a book\"); &#125;) .put(function (req, res) &#123; res.send(\"Update the book\"); &#125;); 6.express.Router使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容： 12345678910111213141516171819202122var express = require(\"express\");var router = express.Router();// middleware that is specific to this routerrouter.use(function timeLog(req, res, next) &#123; console.log(\"Time: \", Date.now()); next();&#125;);// define the home page routerouter.get(\"/\", function (req, res) &#123; res.send(\"Birds home page\");&#125;);// define the about routerouter.get(\"/about\", function (req, res) &#123; res.send(\"About birds\");&#125;);module.exports = router;//接着，在应用程序中装入路由器模块：var birds = require(\"./birds\");app.use(\"/birds\", birds);","categories":[],"tags":[{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"}]},{"title":"html&js","slug":"4.5","date":"2020-04-04T15:23:48.000Z","updated":"2020-04-06T05:07:11.150Z","comments":true,"path":"2020/04/05/4.5/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/04/05/4.5/","excerpt":"","text":"setTimeout()、setInterval()的区别在于？setTimeout()：当方法执行完成定时器就立即停止(但是定时器还在,只不过没用了);setInterval()：当方法执行完成,定时器并没有停止,以后每隔[interval]这么长的时间都会重新的执行对应的方法[function],直到我们手动清除定时器为止; 什么 HTML 结构的语义化？我的理解是让每个标签具有意义而不是无意义的标签 div 和 span；为什么要语义化?为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构；用户体验；有利于 SEO（搜索引擎优化）；便于团队开发和维护，语义化更具可读性，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。 Promise 和 async-await 理解 JSX 最终会被 babel 编译为合法的 JS 语句给 React.createElement()函数调用（编译器在遇到{时采用 JS 语法进行解析，遇到&lt;就采用 HTML 规则进行解析） label 标签 123&lt;label&gt; 标签的 for 属性应当与相关元素（input）的 id 属性相同。&lt;label for=\"jog\"&gt;慢跑&lt;/label&gt;&lt;input type=\"checkbox\" name=\"jog\" id=\"jog\" /&gt;&lt;br /&gt;","categories":[],"tags":[{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"promise","slug":"promise","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/promise/"},{"name":"sql","slug":"sql","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/sql/"},{"name":"js","slug":"js","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/js/"},{"name":"html","slug":"html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/html/"},{"name":"async","slug":"async","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/async/"}]},{"title":"react this keyword","slug":"4.4","date":"2020-04-03T14:23:48.000Z","updated":"2020-04-06T05:02:40.690Z","comments":true,"path":"2020/04/04/4.4/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/04/04/4.4/","excerpt":"","text":"SQL 中 join 操作后面的 on 与 where 的区别得到 on 条件是在 left join 之前先进行条件筛选，而后才对两个表格 join 操作，on 比 where 起作用更早，先根据 on 条件进行多表的连接操作，生成一个临时表再通过 where 来筛选 react 什么时候 render？如果父组件重新渲染，则会发生重新渲染（可能包括新道具）如果调用 this.setState（），将安排重新渲染。 function 的三种类型构造函数：是用于使用 new 关键字创建具有相同原型的新对象的函数 123456789101112131415161718192021222324252627282930313233343536373839function Person() &#123; this.name = \"amitai\";&#125;var newPerson = new Person();console.log(newPerson.name); // ‘amitai’this === newPerson//我们使用它来设置 Person 的实例。调用构造函数时，this.name 的值为“ amitai”。并且对象 newPerson 具有值为 amitai 的属性名称。//普通函数：如果函数不是对象的属性，则它是“普通函数”。function foo() &#123; console.log(this); // undefined in “strict mode” or the global variable&#125;//方法：方法是一个定义为对象属性的函数。var person = &#123; fullName: function () &#123; return this.firstName + \" \" + this.lastName; &#125;,&#125;;person.firstName = \"Amitai\";person.lastName = \"Barnea\"; // 在方法里，this 用于引用对象的其他属性console.log(person.fullName()); // ‘Amitai Barnea’//对象方法和内嵌函数的 this 指向//与变量不同，this 关键字没有作用域，并且嵌套函数不继承其调用者的 this 值,会被当做为普通函数指向 window/global。//如果将嵌套函数作为方法调用，则其 this 值为在其上调用的对象.var person = &#123; fullName: function () &#123; console.log(this); //person var calcFullName = function () &#123; console.log(this); //window/global return this.firstName + \" \" + this.lastName; &#125;; //把返回值换成 this.firstName + \" \" + this.lastName 会正常打印 return calcFullName(); &#125;,&#125;;person.firstName = \"Amitai\";person.lastName = \"Barnea\";console.log(person.fullName()); // Undefined!!! react 怎么操作 dom？大部分情况下你不需要去操作 DOM 元素，你只需要通过设置组件的状态值（setState），react 会通过状态值去渲染组 UI。但是可能在某些情况下你确实需要直接操作 DOM。react 是从 jsx 到虚拟 dom 再从虚拟 dom 生成 dom 的，所以需要在页面生成 DOM 后才能去操作 DOM 节点的，那么很容易让我们相到 react 的几个生命周期，componentDidMount（）就是在组件挂载之后调用的一个生命周期，这时已经生成了 DOM 节点，所以，可以在这个生命周期里 操作 DOM！ 为什么在 componentWillReceiveProps 在中调用 this.setState() 将不会引起第二次渲染？如果不重新渲染，那么获取到的新数据怎么更新到视图上去？ props 有两种调用方式，第一，直接使用这种方式，父组件改变 props 后，子组件重新渲染，由于直接使用的 props，所以我们不需要做什么就可以正常显示最新的 props 12345class Child extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.someThings&#125;&lt;/div&gt;; &#125;&#125; 第二、转换成自己的 state由于我们使用的是 state，所以每当父组件每次重新传递 props 时，我们需要重新处理下，将 props 转换成自己的 state，这里就用到了 componentWillReceiveProps。为什么不会二次渲染是这样的：每次子组件接收到新的 props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的 props 更新 state，更新 state 也会触发一次重新渲染，但 react 不会这么傻，所以只会渲染一次，这对应用的性能是有利的。 1234567891011121314class Child extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; someThings: props.someThings, &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setState(&#123; someThings: nextProps.someThings &#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.someThings&#125;&lt;/div&gt;; &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"dom","slug":"dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"},{"name":"sql","slug":"sql","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/sql/"},{"name":"lifecycle","slug":"lifecycle","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/lifecycle/"},{"name":"js","slug":"js","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/js/"}]},{"title":"mongodb","slug":"4.2","date":"2020-04-01T14:23:48.000Z","updated":"2020-04-06T04:24:42.827Z","comments":true,"path":"2020/04/02/4.2/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/04/02/4.2/","excerpt":"","text":"mongoose.Schemaschema 就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等。在 Mongoose 中，一切都被 Schema 所驱动。在下面程序中，我们定义了一个 UserSchema，这个 UserSchema 对应在 mongoDB 中是一个 UserSchema 集合。该集合有两个属性，一个是 name，类型为 string，另一个是 email，类型也是 string。在 Mongoose 中，所有数据都由一个 Schema 开始创建。每一个 schema 都映射到一个 Mongodb 的集合(collection)，并定义了该集合(collection)中的文档(document)的形式。 1234567891011const UserSchema = new mongoose.Schema(&#123; name: &#123; type: String, required: true, &#125;, email: &#123; type: String, required: true, unique: true, &#125;,&#125;); 理解中间件：将具体业务和底层逻辑解耦的组件，解耦指的是各部分相互独立，也可以通过接口相匹配。大致的效果是：需要利用服务的人（前端写业务的），不需要知道底层逻辑（提供服务的）的具体实现，只要拿着中间件结果来用就好了。express 里的中间件指的在处理请求和发送响应之间的方法/功能/操作。 body-parser 中间件body-parser 是一个 HTTP 请求体解析中间件，使用这个模块可以解析 JSON、Raw、文本、URL-encoded 格式的请求体，Express 框架中就是使用这个模块做为请求体解析中间件。 1app.use(express.json(&#123; extended: false &#125;)); 返回一个仅解析 json 格式数据的中间件，并且让我们通过 req.body 得到 data express-validator 中间件 1const &#123; check, validationResult &#125; = require(\"express-validator/check\"); check，判断合法性等方法。 HTTPhttp headers 里的：Content-Type 标头用于指示资源的媒体类型。媒体类型是与文件一起发送的字符串，指示文件的格式。例如，对于图像文件，其媒体类型将为 png 或 jpg 等. 状态码：200 OK 请求成功。一般用于 GET 与 POST 请求201 Created 已创建。成功请求并创建了新的资源400 Bad Request 客户端请求的语法错误，服务器无法理解403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 服务器无法根据客户端的请求找到资源（网页）500 Internal Server Error 服务器内部错误，无法完成请求 aysnc-await json web token互联网服务一般流程是下面这样:1、用户向服务器发送用户名和密码。2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。3、服务器向用户返回一个 session_id，写入用户的 Cookie。4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。JWT 的方案是服务器不保存 session 数据，所有数据都保存在客户端，每次请求都发回服务器。JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，每当用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 config.get() 使用 config 来管理配置文件eg:config.get(“jwtSecret”),jwtSecret 在配置文件里。 在服务器里 entrypt password 12const salt = await bcrypt.genSalt(10);user.password = await bcrypt.hash(passwork, salt); 异步原理：js 是单线程，意味着排队执行，如果计算量大，cpu 会忙不过来。设计者意识到主线程完全可以不管 io 阻塞，挂起处于等待中的任务，先运行排在后面的任务，等到 io 阻塞返回了结果，再把挂起的任务执行下去。","categories":[],"tags":[{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"},{"name":"middleware","slug":"middleware","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/middleware/"},{"name":"http","slug":"http","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/http/"},{"name":"aysnc","slug":"aysnc","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/aysnc/"},{"name":"异步","slug":"异步","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"mongoose","slug":"mongoose","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/mongoose/"}]},{"title":"CICD","slug":"4.3","date":"2020-04-01T14:23:48.000Z","updated":"2020-04-06T04:30:53.568Z","comments":true,"path":"2020/04/02/4.3/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/04/02/4.3/","excerpt":"","text":"CICDCI 的英文名称是 Continuous Integration，中文翻译为：持续集成。CI 中，开发人员将会频繁地向主干提交代码，这些新提交的代码在最终合并到主干前，需要经过编译和自动化测试流进行验证。 持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程。持续集成的目标是快速确保开发人员新提交的变更是好的，并且适合在代码库中进一步使用。CI 的流程执行和理论实践让我们可以确定新代码和原有代码能否正确地集成在一起。 CD 可对应多个英文名称，持续交付 Continuous Delivery 和持续部署 Continuous Deployment 。持续交付完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中或发布给最终使用的用户。持续部署对于一个成熟的 CI/CD 管道（Pipeline）来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。持续交付并不是指软件每一个改动都要尽快部署到产品环境中，它指的是任何的代码修改都可以在任何时候实施部署。持续交付表示的是一种能力，而持续部署表示的则一种方式。持续部署是持续交付的最高阶段","categories":[],"tags":[{"name":"CICD","slug":"CICD","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/CICD/"}]},{"title":"this keyword of react","slug":"4.1","date":"2020-03-31T14:23:48.000Z","updated":"2020-04-06T04:17:32.682Z","comments":true,"path":"2020/04/01/4.1/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/04/01/4.1/","excerpt":"","text":"为什么用 react hooks？允许创建每个组件为函数组件。更简单的在组件中分享状态逻辑。 React FragmentsReact 中常见模式是为一个组件返回多个元素。为了包裹多个元素你肯定写过很多的 div 和 span，进行不必要的嵌套，无形中增加了浏览器的渲染压力。Fragments 简写形式&lt;&gt;&lt;/&gt;。 this 指向 1.普通函数 — this 指向函数的调用对象 1234567function f() &#123; var user = \"XX\"; console.log(this.user); //undefined console.log(this); //window&#125;f(); //这里f 的调用等同于window.f(); 所以f函数内部this指向的是window 2.对象方法中调用 —- this 指向上级对象 123456789101112131415161718192021222324252627282930313233343536var obj = &#123;user:\"xxx\",fn:function()&#123; console.log(this.user); //xxx&#125;&#125;obj.fn();//这里要注意一点，就是在对象中可能有多层嵌套的对象，但是this指向的都是他调用地方的上级对象var obj = &#123;user:\"xxx\",b: &#123;user: \"bbb\",fn:function()&#123; console.log(this.user); // bbb&#125;&#125;&#125;obj.b.fn();//如上，虽然是在obj里面this调用，但是因为是在obj.b这个对象中，所以this指向的是 obj.b注意不能只看上级对象，更关键的是调用对象var obj = &#123;user:\"xxx\",b: &#123;user: \"bbb\",fn:function()&#123; console.log(this.user); // undefined&#125;&#125;&#125;var f = obj.b.fn;f()//如上，this其实是在f执行的时候调用的，这时候，f的this的调用对象是window,那么就可以理解window.user为undefined 构造函数 — this 指向 new 出来的对象 123456function Fn()&#123;this.user = \"xxx;&#125;var a = new Fn(); console.log(a.user); //xxx//new 的过程其实也是初始化了一个新的对象，然后用新的对象调用原先的函数 Fn.call(a) 这个情况跟下面这种情况类似了。 4.apply, call, bind 通过改变函数的调用对象而改变 this 的指向 1234567function foo() &#123; console.log(\"id:\", this.id); //42&#125;var id = 21;foo.call(&#123; id: 42 &#125;); //foo函数的调用对象变成了 &#123;id: 42&#125;,所以this指向发生了变化 5.箭头函数 this 的指向 —- this 指向其定义时候的对象 1234567891011121314151617181920212223242526name = \"peter\";const a = &#123; name: \"tony\", c: (this.name = \"lily\"), b: console.log(\"1\", name), //peter,函数里this指向global(node)/window ; 最先打印出 jiantou: () =&gt; &#123; console.log(this); //若注解c: (this.name = \"lily\"),this === &#123;&#125;,指的定义处上下文;否则&#123;this.name = \"lily\"&#125; console.log(this.name); //lily &#125;, putong: function () &#123; console.log(this); /* obj a &#123; name: 'tony', b: undefined, jiantou: [Function: jiantou], putong: [Function: putong] &#125; */ console.log(this.name); //tony &#125;,&#125;;a.jiantou();a.putong();typeof a.b; //undefined 箭头函数的 this 在定义时所在的对象，其实质是因为箭头函数没有自己的 this,用的是外层的 this。普通函数的 this 是看的是它执行时候的调用对象; 箭头函数的 this 与它的执行没有关系，在定义的时候就决定了。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]},{"title":"React 的生命周期","slug":"3.30","date":"2020-03-29T14:23:48.000Z","updated":"2020-04-06T05:05:52.329Z","comments":true,"path":"2020/03/30/3.30/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/30/3.30/","excerpt":"","text":"Virtual DOM 工作原理Virtual DOM 是一个轻量级的 JavaScript 对象。它是一个节点树，将元素、它们的属性和内容作为对象及其属性，可以理解为树上的每个节点。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。计算之前 DOM 表示与新表示的之间的差异。完成计算后，将只用实际更改的内容更新 real DOM。 React 的生命周期方法有哪些componentWillMount:在渲染之前执行，用于根组件中的 App 级配置。componentDidMount：在第一次渲染之后执行，可以在这里做 AJAX 请求，DOM 的操作或状态更新以及设置事件监听器。componentWillReceiveProps：在初始化 render 的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染shouldComponentUpdate：确定是否更新组件。默认情况下，它返回 true。如果确定在 state 或 props 更新后组件不需要在重新渲染，则可以返回 false，这是一个提高性能的方法。componentWillUpdate：在 shouldComponentUpdate 返回 true 确定要更新组件之前执行。componentDidUpdate：它主要用于更新 DOM 以响应 props 或 state 更改。componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"virtual dom","slug":"virtual-dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/virtual-dom/"},{"name":"lifecycle","slug":"lifecycle","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/lifecycle/"}]},{"title":"this keyword of react","slug":"3.29","date":"2020-03-28T14:23:48.000Z","updated":"2020-04-06T04:13:44.463Z","comments":true,"path":"2020/03/29/3.29/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/29/3.29/","excerpt":"","text":"react 中 this 指向发现还是对 this 指向掌握不明确，看完这个博客清晰多了。React 是通过创建虚拟 DOM，然后将虚拟 DOM 生成真实的 DOM，最后插入到页面中，而 React 生命周期中 render 方法的作用就是将虚拟 DOM 渲染成真实 DOM。在 JSX 语法中: onClick={ function } onClick 这个属性本身只是一个”中间变量”。将函数赋值给 onClick 这个中间变量，后面不仅要进行 JSX 语法转化,将 JSX 组件转换成 Javascript 对象,还要再将 Javascript 对象转换成真实 DOM。前提：JS 中的 this 是由函数调用者调用的时候决定的。把 onClick 作为中间变量,指向一个函数的时候,后面的一系列处理中，使用 onClick 这个中间变量所指向的函数，里面的 this 自然就丢失掉了，不是再指向对象实例了。 实例 12345678910111213141516171819const test = &#123; name: \"jack\", getName: function () &#123; console.log(this.name); &#125;,&#125;;test.getName();//使用node test.js执行上述代码可以正常输出jack。 之后，我们对代码进行调整：const test = &#123; name: \"jack\", getJack: function () &#123; console.log(this.name); &#125;,&#125;;//如果传递一个函数名给一个变量，之后通过函数名()的方式进行调用，在方法内部如果使用this则this的指向会丢失const func = test.getJack;func();//我们没有直接调用对象的方法，而是将方法声明给一个中间变量，之后利用中间变量()调用方法，此时 this 则失去指向，输出 undefined，如果使用 node 环境执行 js 文件则输出 node 相关信息，如嵌入到 html 中则 this 指向 window 对象。 React 事件绑定React 中的 bind 同上方原理一致,在 JSX 中传递的事件不是一个字符串，而是一个函数（如:onClick={this.handleClick}），此时 onClick 即是中间变量，所以处理函数中的 this 指向会丢失。解决这个问题就是给调用函数时 bind(this)，从而使得无论事件处理函数如何传递，this 指向都是当前实例化对象。 当然，如果不想使用 bind(this)，我们可以在声明函数时使用箭头函数将函数内容返回给一个变量，并在调用时直接使用 this.变量名即可。 React 没有自动的把 bind 集成到 render 方法中呢?因为 render 多次调用每次都要 bind 会影响性能，所以官方建议 constructor 中手动 bind 达到性能优化。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]},{"title":"react-router","slug":"3.28","date":"2020-03-27T14:23:48.000Z","updated":"2020-04-06T04:04:40.200Z","comments":true,"path":"2020/03/28/3.28/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/28/3.28/","excerpt":"","text":"前端路由与后端路由后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。 MVCMVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。1）最上面的一层，是直接面向最终用户的视图层（View）。它是提供给用户的操作界面，是程序的外壳。2）最底下的一层，是核心的数据层（Model），也就是程序需要操作的数据或信息。3）中间的一层，就是控制层（Controller），它负责根据用户从视图层输入的指令，选取数据层中的数据，然后对其进行相应的操作，产生最终结果。这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。 SPA Single Page Application单页应用程序是一个 Web 应用程序，其中客户端 JavaScript 处理路由而不是后端。优点有：SPA 非常易于部署到生产环境中。SPA 快速且易于使用，因为您不必等待重新加载页面。应用程序会动态加载状态。由于该应用程序使用较少的带宽，并且该应用程序的整体性能超过了典型的前端/后端应用程序的性能，因此可以改善用户体验。 复习 sqlGROUP BY–根据(by)一定的规则进行分组(Group)。 它的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对若干个小区域进行数据处理。 1234567SELECT Customer,SUM(OrderPrice) FROM OrdersGROUP BY Customer ----查找每个客户的总金额HAVING --在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。SELECT Customer,SUM(OrderPrice) FROM OrdersWHERE Customer=\"Bush\" OR Customer=\"Adams\"GROUP BY CustomerHAVING SUM(OrderPrice)&gt;1500----查找客户 Bush 或 Adams 拥有超过 1500 的订单总金额 react-router路由器对象有两种类型。浏览器路由器哈希路由器如果我们要处理动态请求，请使用 BrowserRouter；如果要处理静态请求，请使用 HashRouter。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//index.jsimport &#123; BrowserRouter &#125; from \"react-router-dom\";import App from \"./App\";ReactDOM.render( &lt;BrowserRouter&gt; &#123;\" \"&#125; &lt;App /&gt;&#123;\" \"&#125; &lt;/BrowserRouter&gt;, document.getElementById(\"root\"));//three compoents:home,contract,about//app.jsclass App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;h2&gt;Welcome to React Router Tutorial&lt;/h2&gt; &lt;nav className=\"navbar navbar-expand-lg navbar-light bg-light\"&gt; &lt;ul className=\"navbar-nav mr-auto\"&gt; &lt;li&gt; &lt;Link to=&#123;\"/\"&#125; className=\"nav-link\"&gt; Home &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;\"/contact\"&#125; className=\"nav-link\"&gt; Contact &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;\"/about\"&#125; className=\"nav-link\"&gt; About &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/contact\" component=&#123;Contact&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; Router 是 react 路由的外层盒子，里面的内容就是单页面应用的路由以及路由组件。Router 下面只能包含一个盒子标签，类似这里的 div。 Link 是点击切换到哪一组件的链接。Link 代表一个链接，在 html 界面中会解析成 a 标签。作为一个链接，必须有一个 to 属性，代表链接地址。这个链接地址是一个相对路径。 Route 代表路由有一个 path 和一个组件属性（也以 component、render 等等）。path 代表相对路径，component 代表组件。 Switch 只会渲染第一个路径，不用则会使每一个被匹配到的 Route 都会被渲染。只找到第一个被 location 匹配到的 route 就停止匹配。","categories":[],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-router/"},{"name":"sql","slug":"sql","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/sql/"},{"name":"SPA","slug":"SPA","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/SPA/"},{"name":"MVC","slug":"MVC","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/MVC/"}]},{"title":"express","slug":"3.24","date":"2020-03-23T14:23:48.000Z","updated":"2020-04-06T03:52:22.320Z","comments":true,"path":"2020/03/24/3.24/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/24/3.24/","excerpt":"","text":"express 12const express = require(express); const app = express();app.listen(3000, function() &#123; console.log(listening on 3000) &#125;) Express 处理 GET 请求通过 get method:app.get(path, callback)path 是 domain 后面的内容，callback 是当路径匹配时 server 将要做什么；app.get(/, function(req, res) { res.send(Hello World) })用 respons 给浏览器写一个”Hello World”； 1app.get(/, (req, res) =&gt; &#123; res.sendFile(\\_\\_dirname + /index.html) &#125;) 将 index.html 页面放回到浏览器中 仅当 POST 请求发送到服务器时，CREATE 操作才由浏览器执行 123&lt;form action=/quotes method=POST&gt;&lt;input type=text placeholder=name name=name&gt; &lt;input type=text placeholder=quote name=quote&gt;&lt;button type=submit&gt;Submit&lt;/button&gt; &lt;/form&gt; action 属性告诉浏览器在我们的 Express 应用中导航到的位置。在这种情况下，我们导航到/ quotes。method 属性告诉浏览器发送什么请求。在这种情况下，这是一个 POST 请求。 1app.post(/quotes, (req, res) =&gt; &#123; console.log(Hello!) &#125;) 重新启动服务器并刷新浏览器。然后，在表单元素中输入一些内容。能够看到 Hello！在命令行中。 1const bodyParser= require(body-parser)app.use(bodyParser.urlencoded(&#123;extended: true&#125;)) Express 允许我们使用 use 方法向应用程序中添加诸如 body-parser 之类的中间件。在处理 Express 时，经常听到“中间件”一词。这些东西基本上是在我们的应用程序处理它们之前更改请求或响应对象的插件。 1app.post(/quotes, (req, res) =&gt; &#123; console.log(req.body) &#125;) body-parser 中的 urlencoded 方法告诉 body-parser 从元素中提取数据并将其添加到请求对象的 body 属性中。 nodenpm install nodemon –save-dev–save-dev 标志会将 Nodemon 保存为您的 package.json 文件中的 devDependency。{ // … scripts: { dev: nodemon server.js } // … }现在可以运行 npm run dev 来触发 nodemon server.js。 npm install mongodb –savecollection 是一个存东西的命名空间. 9321ass9321 这次的 assignment 主要用 flask 框架和数据库交互来写 api，数据是从网页的 json 格式数据读到数据库里，然后将数据渲染在 swagger-ui 页面上，有 7 个不同的功能（增删改查）。主要运用了 Flask-RESTful 和 sqlite 等包。","categories":[],"tags":[{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"},{"name":"comp9321","slug":"comp9321","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/comp9321/"}]},{"title":"Scss","slug":"3.23","date":"2020-03-22T14:23:48.000Z","updated":"2020-04-06T02:10:19.206Z","comments":true,"path":"2020/03/23/3.23/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/23/3.23/","excerpt":"","text":"scss 变量用来存储需要在 CSS 中复用的信息，例如颜色和字体。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 是过度的使用嵌套会让产生的 CSS 难以维护，因此是一种不好的实践 1234567891011nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125;&#125; SASS 能够将代码分割为多个片段，并以 underscore 风格的下划线作为其命名前缀,SASS 会通过这些下划线来辨别哪些文件是 SASS 片段，并且不让片段内容直接生成为 CSS 文件，从而只是在使用@import 指令的位置被导入. 1234567891011121314// _reset.scsshtml,body,ul,ol &#123; margin: 0; padding: 0;&#125;// base.scss@import \"reset\";body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef;&#125; 混合（Mixin）用来分组那些需要在页面中复用的 CSS 声明，开发人员可以通过向 Mixin 传递变量参数来让代码更加灵活 12345678910@mixin border-radius($radius) &#123; border-radius: $radius; -ms-border-radius: $radius; -moz-border-radius: $radius; -webkit-border-radius: $radius;&#125;.box &#123; @include border-radius(10px);&#125; 上面的代码建立了一个名为 border-radius 的 Mixin，并传递了一个变量$radius 作为参数，然后在后续代码中通过@include border-radius(10px)使用该 Mixin，最终编译的结果如下： 123456.box &#123; border-radius: 10px; -ms-border-radius: 10px; -moz-border-radius: 10px; -webkit-border-radius: 10px;&#125; 继承是 SASS 中非常重要的一个特性，可以通过@extend 指令在选择器之间复用 CSS 属性，并且不会产生冗余的代码 12345678910111213141516171819202122232425262728293031// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。%other-styles &#123; display: flex; flex-wrap: wrap;&#125;// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。%message-common &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.message &#123; @extend %message-common;&#125;.success &#123; @extend %message-common; border-color: green;&#125;.error &#123; @extend %message-common; border-color: red;&#125;.warning &#123; @extend %message-common; border-color: yellow;&#125; 操作符SASS 提供了标准的算术运算符，例如+、-、*、/、%。 1234aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125; Scss 允许 CSS 规则嵌套使用，父子规则将会呈现包含选择器的关系,可以避免重复的使用父级选择器，从而达到简化 CSS 代码结构的目的.Scss 使用$关键字在 CSS 规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下： 12345/*===== SCSS =====*/a &#123;font-weight: bold;text-decoration: none;&amp;:hover &#123; text-decoration: underline; &#125; Scss 当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下","categories":[],"tags":[{"name":"Scss","slug":"Scss","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Scss/"}]},{"title":"react","slug":"3.22","date":"2020-03-21T14:23:48.000Z","updated":"2020-03-28T05:04:57.212Z","comments":true,"path":"2020/03/22/3.22/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/22/3.22/","excerpt":"","text":"除了构造函数和生命周期钩子函数里会自动绑定 this 为当前组件外，其他的都不会自动绑定 this 的指向为当前组件。如果你在 JSX 里忘记将 this 绑定到 this.handleClick 并把它传入了 onClick，那么当你调用这个函数的时候 this 的值为 undefined。 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。 1&lt;span&gt;欢迎&#123;isQbVip &amp;&amp; &lt;a&gt;请尽快升级为正式 Vip!&lt;/a&gt;&#125;&lt;/span&gt; 如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]},{"title":"social network project","slug":"3.21","date":"2020-03-20T14:23:48.000Z","updated":"2020-03-27T10:54:07.709Z","comments":true,"path":"2020/03/21/3.21/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/21/3.21/","excerpt":"","text":"今天做的 project 内容是 express 对 server 的配置包括路由以及连接 MongoDB，让我对后端的结构有一个初步的理解。主要是以下几个点： 设置 PORT 环境变量并且告诉服务器去哪监听；若没有，本地在 5000 端口 。 1const PORT = process.env.PORT || 5000; app.use(/api/users, require(./routers/api/users));路由规则是 app.use(path,router)定义的，router 代表一个由 express.Router()创建的对象，在路由对象中可定义多个路由规则。每次将请求发送到服务器时，都会调用各个 app.use（middleware） app.use 和 app.get 的区别app.use(path,callback)中的 callback 既可以是 router 对象又可以是函数app.get(path,callback)中的 callback 只能是函数给 app.get(app.post、app.put 同理)赋个路由对象是不行的 获取 mongoURIcluster 连接自己的 app，设置安全地址等 mongodb 连接配置每次用 async 函数时，都要用 try-catch 函数来判断失败情况","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"}]},{"title":"backend staff","slug":"3.19","date":"2020-03-18T14:23:48.000Z","updated":"2020-03-28T05:04:57.211Z","comments":true,"path":"2020/03/19/3.19/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/19/3.19/","excerpt":"","text":"mongodbsharded cluster：同一个集合的不同子集分发存储到不同的机器（shard）上，Mongodb 使用 sharding 机制来支持超大数据量，将不同的 CRUD 路由到不同的机器上执行，提到了数据库的吞吐性能。collection：table 的集合。 Mongoose 是在 node.js 环境下对 mongodb 进行便捷操作的对象模型工具 AJAXAJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。Ajax 的工作原理相当于在用户和服务器之间加了一个中间层(ajax 引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给 Ajax 引擎自己来做, 只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求。把这些交给了 Ajax 引擎，用户操作起来也就感觉更加流畅了。 jQueryAJAX load 方法可以从服务器加载数据，并把返回的数据放入被选元素中 jQuery get()和 post()方法用于通过 HTTP GET 或 POST 请求从服务器请求数据 jQuery 提供了 children() 和 find() 方法用于向下遍历 DOM 树，以查找元素的后代。jQuery 提供了 parent() 、parents() 和 parentsUntil() 方法用于向上遍历 DOM 树，以查找元素的祖先。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/ajax/"},{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"}]},{"title":"Reat Hooks","slug":"3.18","date":"2020-03-17T14:23:48.000Z","updated":"2020-04-06T01:56:23.383Z","comments":true,"path":"2020/03/18/3.18/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/18/3.18/","excerpt":"","text":"todoList app加深了对 ES6，react hook，Jsx 的理解；useState(initialState) 可以接收新的 state 或者一个返回 state 的函数； 用 Hooks 实现生命周期每次 Render 都有自己的 Props 与 State。每次一 function 结束 rendering，useeffect 就会被调用。 format: useEffect(()=&gt;{}, [state])useEffect 会调用当 state 变化的时候，如果是空数组[],则 hook 不会被调用。 1234567fetch from Apiformat: useEffect(async ()=&gt;&#123;const response = await fetch(&amp;quot;url&amp;quot;);const data = await response.json();const [item] = data.results;setPerson(item);&#125;, [state]) DOM 操作DOM 就是浏览器为 JavaScript 提供的一系列接口，通过这些接口我们可以操作 web 页面。document.title 设置文档标题等价于 HTML 的 title 标签。innerHTML 与 outerHTML 的区别？innerHTML：内部 HTML，content；outerHTML：外部 HTML，content；innerText：内部文本，content；outerText：内部文本，content；摘自：React Hooks(2019)入门教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"dom","slug":"dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-hooks/"}]},{"title":"event-loop","slug":"3.15","date":"2020-03-14T14:23:48.000Z","updated":"2020-03-28T05:04:57.212Z","comments":true,"path":"2020/03/15/3.15/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/15/3.15/","excerpt":"","text":"jQuery 的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作. JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 异步任务指的是，不进入主线程、而进入任务队列（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。（3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 所谓回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，任务队列上第一位的事件就自动进入主线程。 ajax：可以在不重新加载整个网页的情况下，对网页的某部分进行更新。只要是 JS 调用异步通讯组件并使用格式化的数据来更新 web 页面上的内容或操作过程，那么我们用的方法就可算是 AJAX 摘自：阮一峰","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"event loop","slug":"event-loop","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/event-loop/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/ajax/"}]},{"title":"express","slug":"3.14","date":"2020-03-13T14:23:48.000Z","updated":"2020-03-16T01:30:15.645Z","comments":true,"path":"2020/03/14/3.14/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/14/3.14/","excerpt":"","text":"express 简介中间件：在 express 应用中，一切皆中间件。各种应用逻辑，如 cookie 解析、会话处理、日志记录、权限校验等，都是通过中间件来完成的。路由：负责寻址。比如用户发送了个 http 请求，该定位到哪个资源，就是路由说了算。模板引擎：负责视图动态渲染。 express.Router 模板引擎是一个将页面模板和数据结合起来生成 html 的工具。app.set(‘views’, path.join(__dirname, ‘views’))// 设置存放模板文件的目录app.set(‘view engine’, ‘ejs’)// 设置模板引擎为 ejs 通过调用 res.render 函数渲染 ejs 模板，res.render 第一个参数是模板的名字，这里是 users 则会匹配 views/users.ejs，第二个参数是传给模板的数据。用 includes 拆分模板组件通常有两个好处：模板可复用，减少重复代码主模板结构清晰 中间件与 nextexpress 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递，如内置的 res.render 其实就是渲染完 html 直接返回给客户端，没有调用 next()，从而没有传递给下一个中间件","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"}]},{"title":"react+redux 项目流程","slug":"3.13","date":"2020-03-12T14:23:48.000Z","updated":"2020-03-16T01:14:16.168Z","comments":true,"path":"2020/03/13/3.13/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/13/3.13/","excerpt":"","text":"restful Api 资源表现层状态转化资源是一种信息实体，它可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。如果客户端想要操作服务器，必须通过某种手段，让服务器端发生状态转化（State Transfer）。而这种转化是建立在表现层之上的，所以就是表现层状态转化。 react+redux 小项目流程 先 render 组件 componentDidMount (最常见的 fetch data 的地方就是在 componentDidMount 里) 1234567 componentDidMount() &#123; /*因为有 action 被发现 一被调用立即执行 dispatch function store.dispatch(fetchpost()); */ this.props.fetchPosts();&#125; action creator 对 api 请求负责初始化export default axios.create({baseURL: https://jsonplaceholder.typicode.com}); action creator 使用 axios 去做出 api 请求action 会被立刻 dispatch 被 reducers 执行，但是 api 请求是有 delay 的。所以需要异步 action creator，即中间件 redux-thunk 帮助我们能去完成发出请求的操作。 12345678910export const fetchPosts = () =&gt; &#123;return async (dispatch, getstate) =&gt; &#123;const response = await json.get(/posts);dispatch(&#123; type: FETCH_POSTS, payload: response.data &#125;);&#125;;&#125;;export const fetchUser = id =&gt; async dispatch =&gt; &#123;const response = await json.get(`/users/$&#123;id&#125;`);dispatch(&#123; type: FETCH_USER, payload: response.data &#125;);&#125;; async 函数返回值是 Promise 对象，给了我们获取 data 的权限。中间件：action creator 返回 function 或者 object，被 dispatch 到中间件，在中间件里会有 if 判断是 function 还是 object；如果是 obj，会直接到 reducers 里；如果是 function，会调用这个 function 以及 dispatch 和 getstate function。 api 返回 datadispatch({ type: FETCH_POSTS, payload: response.data }); action creator 返回一个带有 fetched data 的 action，dispatch 给 reducers。 reducer 接收 action 并且通过 payload 数据返回一个新 state。注意：必须返回除了 undefined 以外的值 []是可以的；state = null，第一次调用 state 默认是 null，表示现在没有被选择的值；第二次调用的时候，state 是由第一次 return 出来的 state 和 action2 产生。 12345678export default (state = [], action) =&gt; &#123; switch (action.type) &#123; case FETCH_USER: return [...state, action.payload]; default: return state; &#125;&#125;; 新的 state 会被作为 props 传入 react 组件，造成重新渲染。store 可以看作是 state 的集合。 1234const mapStateToProps = state =&gt; &#123; return &#123; posts: state.posts &#125;;&#125;;export default connect(mapStateToProps, &#123; fetchPosts &#125;)(PostList);","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"restful api","slug":"restful-api","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/restful-api/"}]},{"title":"Redux","slug":"3.12","date":"2020-03-11T14:23:48.000Z","updated":"2020-03-16T01:26:02.006Z","comments":true,"path":"2020/03/12/3.12/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/12/3.12/","excerpt":"","text":"Redux redux 作用？随着应用复杂度地不断提升，组件之间的状态通信变得越来越多，组件之间的耦合也变得越来越重。redux 能更好维护的模块间通信。 Redux 的单一状态树所有的 state 都以一个对象树的形式储存在一个单一的 store 中。页面中的所有状态 or 数据，都应该用这种状态树的形式来描述；页面上的任何变化，都应该先去改变这个状态树，然后再通过某种方式实现到页面上。 action 123456function changeText() &#123; return &#123; type: \"CHANGE_TEXT\", payload: \"Hello\" &#125;;&#125; Action 的任务是描述“发生了什么事情？”，这个函数会返回一个 Action 对象，这个对象里描述了“页面发生了什么”。随后这个对象会被传入到 Reducer 中。 reducer(state, action) =&gt; newStateReducer 的任务是根据传入的 Action 对象去修改状态树。Reducer 是一个纯函数， 根据传入的 当前 state 和 action ，返回一个新的 state 。 Storelet store = createStore(Reducer);state 是 store 的映射；Store 就是把 Reducer 和 action 联系到一起的对象。Store 有以下职责：维持应用的 state；提供 getState() 方法获取 state；提供 dispatch(action) 方法更新 state；通过 subscribe(listener) 注册监听器； 异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。中间件解决了这个问题。 什么是中间件？中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 摘自：阮一峰 知乎 er","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"}]},{"title":"express","slug":"3.11","date":"2020-03-10T14:23:48.000Z","updated":"2020-03-16T01:26:35.555Z","comments":true,"path":"2020/03/11/3.11/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/11/3.11/","excerpt":"","text":"express webpack 作用及流程component 必须返回 jsx，每次当 state 变化，组件重新渲染比如 webpack 会把 jsx 语句转化为 bundle.jswebpack 流程介绍 express 项目结构其中 app.js 是入口文件，views 文件夹下面放置的是需要渲染的模板文件，package.json 是整个项目的配置文件，.gitignore 文件里面写明文件 pull 到 github 时不需要上传的文件或文件夹，如 node_modules 文件夹。 app.js js 框架与模板引擎的区别模板引擎，就是将 HTML 模板渲染出最终样子的工具。把动态把数据填充到 HTML 里面，可以在服务器端做，也可以在浏览器端做比如 angular 会根据取到的数据去填充}里的内容，这是在客户端完成的。比如 JSP 会在服务器端去填充{$}里的内容，然后把最终的 html 送到浏览器，这是服务器端完成的。有时候前后端模板引擎会同时使用，即使有前端的模板引擎，后端返回 HTML 有时也是需要的，不仅仅返回是 JSON 数据区别：前后端分离可以大大将服务端的压力分散给客户端，而客户端的计算性能损耗几乎是微乎其微，并且在开发流程上，效率也极大提升，也可以适应敏捷开发。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"}]},{"title":"Webpack","slug":"3.10","date":"2020-03-09T14:23:48.000Z","updated":"2020-03-17T11:33:06.253Z","comments":true,"path":"2020/03/10/3.10/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/10/3.10/","excerpt":"","text":"Webpack 什么是 Webpack?WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。 为什要使用 WebPack?今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的 JavaScript 代码和一大堆依赖包。为了简化开发的复杂度，有不少好的实践方法a:模块化，让我们可以把复杂的程序细化为小的文件;b:类似于 TypeScript 这种在 JavaScript 基础上拓展的开发语言：使我们能够实现目前版本的 JavaScript 不能直接使用的特性，并且之后还能能装换为 JavaScript 文件使浏览器可以识别。 Webpack 的工作方式是?在 webpack 看来一切都是模块！他会把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个浏览器可识别的 JavaScript 文件。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/webpack/"}]},{"title":"React Hooks","slug":"3.9","date":"2020-03-08T14:23:48.000Z","updated":"2020-03-16T00:40:22.652Z","comments":true,"path":"2020/03/09/3.9/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/09/3.9/","excerpt":"","text":"react hook React 的核心思想是，一个 UI 组件响应一个 state 变化。 不使用 setState 更新 React 中的 state。React 组件不再是 ES6 class，它是一个纯粹而简单的 JavaScript 函数。const [buttonText, setButtonText] = useState(“Click me, please”);[state 值,state 更新函数] useEffect 获取数据替代 componentDidMount 在 React 中获取数据。useEffect 与 React 类中的 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途，但统一为单个 API。比如，在 useEffect 中调用 fetch。而且可以使用 setData（从 useState 中提取的更新函数）代替 this.setState。“useEffect 与 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途”componentDidUpdate！ componentDidUpdate 是一个生命周期方法，每当组件获得新的 props 或 state 发生变化时就会运行。如果直接调用 useEffect，你会看到无限循环。我们需要传递一个空数组作为 useEffect 的第二个参数：[]。 12345useEffect(() =&gt; &#123; fetch(\"http://localhost:3001/links/\") .then(response =&gt; response.json()) .then(data =&gt; setData(data));&#125;, []); 使用带有 React Hooks 的 render props 吗？没有意义。那是因为 React Hooks 诞生的原因的：在组件之间共享逻辑。有了一个标准的、干净的方式来封装和共享逻辑。 可以在 useEffect 中使用 async/await 吗?不能直接使用。那是因为 JavaScript 异步函数总是返回一个 promise，而 useEffect 只能返回另一个函数。如果你要在 useEffect 中使用 setInterval 定时器，我们应该返回一个函数（闭包）来清除 setInterval。 摘自：React Hooks(2019)入门教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-hooks/"}]},{"title":"git","slug":"3.8","date":"2020-03-07T14:23:48.000Z","updated":"2020-03-10T05:44:07.970Z","comments":true,"path":"2020/03/08/3.8/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/08/3.8/","excerpt":"","text":"今天算是做完了 9321 的第一个 assignment，考察了对 python 里几个包的运用，pandas、matplotlib 等，主要是用 python 进行数据处理和可视化，还是蛮简单的。 顺便记录一下 git 的基本操作。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"unsw","slug":"unsw","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/unsw/"},{"name":"git","slug":"git","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/git/"}]},{"title":"Node","slug":"3.7","date":"2020-03-06T14:23:48.000Z","updated":"2020-03-07T14:52:01.490Z","comments":true,"path":"2020/03/07/3.7/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/07/3.7/","excerpt":"","text":"Node 为什么说 nodejs 是单线程语言呢？这是因为 nodejs 中 javascript 代码的执行是单线程；但 node 确实只有一个主线程，但是底层工作的线程却有多个。遇到异步时，主线程发出操作指令，然后就可以去做别的事情了（主线程不需要等待），所有操作完成后再执行回调。主线程什么时候知道操作完成执行回调，则通过 event loop 机制循环遍历。 nodejs 的异步 IO当需要 IO(网络 IO/文件 IO)操作时，单线程的 javascript 并不会停下来等待 IO 操作完成，而是“事件驱动”开始介入，javascript 执行线程继续执行未完的 javascript 代码，当执行完成后该线程处于空闲状态 事件循环Node.js 应用启动时，V8 引擎会执行你写的应用代码，保持一份观察者（注册在事件上的回调函数）列表。当事件发生时，它的回调函数会被加进一个事件队列。只要这个队列还有等待执行的回调函数，事件循环就会持续把回调函数从队列中拿出并执行。 4. 123456789//module 是一个 obj，有一个 exports 属性导出 function 或者 objmodule.exports.func = funcmodule.exports.endPoint = url (keep url private)require(\"./相对路径\")const path = require(\"path\")const pathObj = path.parse(\\_\\_filename)//包含 dir 地址，root，name 等属性const os = require(\"os\")//包含内存等等属性","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"node","slug":"node","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/node/"}]},{"title":"JS","slug":"3.6","date":"2020-03-05T14:23:48.000Z","updated":"2020-03-08T00:21:01.878Z","comments":true,"path":"2020/03/06/3.6/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/06/3.6/","excerpt":"","text":"JS 高阶函数123456789101112131415161718192021222324252627//forEach[1, 2, 3].forEach((item, index, arr) =&gt; &#123; //do something //handle in this array not a new array;&#125;);//mapconst newArr = [1, 2, 3].map((item, index, arr) =&gt; &#123; //do something //handle in a new array;&#125;);//filterconst evens = [1, 2, 3].filter((item, index) =&gt; &#123; //return true or false; //true will put the item back to the new array&#125;);//reduceconst evens = [1, 2, 3].reduce((prev, next) =&gt; &#123; //prev item and next item will do some kind of calculation; //return a number&#125;, randomNumAsStartNum);//some,every return true or false;//some: if any item satisfy the condition,return true//every: if all items satisfy the condition,return true","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"css grid","slug":"3.5","date":"2020-03-04T14:23:48.000Z","updated":"2020-03-08T00:21:01.878Z","comments":true,"path":"2020/03/05/3.5/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/05/3.5/","excerpt":"","text":"css grid grid 构成 Grid Container) 应用 display: grid 的元素网格项(Grid Item) 网格容器（Grid Container）的子元素（例如直接子元素）网格线(Grid Line) 网格轨道(Grid Track) 网格单元格(Grid Cell) 网格区域(Grid Area) grid 属性学习了各种网格容器属性以及网格项属性；两个教程：https://www.html.cn/archives/8510http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 网格容器与网格项结构 属性分为三大类：grid container;grid item;以及 grid 里的 content","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css grid","slug":"css-grid","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-grid/"}]},{"title":"css flex box","slug":"3.4","date":"2020-03-03T14:23:48.000Z","updated":"2020-03-16T01:14:46.576Z","comments":true,"path":"2020/03/04/3.4/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/04/3.4/","excerpt":"","text":"css flex box在 flex 布局中，flex 项（就是子元素）要么按照 main axis(主轴)（从 main-start 到 main-end ）排布，要么按照 cross axis(交叉轴) (从 cross-start 到 cross-end)排布。了解六个容器属性等。 两个极好的教程:CSS3 Flexbox 布局完全指南阮一峰","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css flex box","slug":"css-flex-box","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-flex-box/"}]},{"title":"css box model and positioning","slug":"3.3","date":"2020-03-03T01:57:48.000Z","updated":"2020-03-07T14:45:42.404Z","comments":true,"path":"2020/03/03/3.3/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/03/3.3/","excerpt":"","text":"css box model 所有元素在 css 里都会是一个 box； margin 是该 box 与其他 box 的距离，而 padding 是该盒子边界与内容区的距离 当两个 box 相邻时，margin 会塌陷（重叠），选 box margin 大的那一个作为距离 box-sizing 属性：border-box，内容区宽度或高度会自动调整padding + border + 内容 width= 盒子的宽度padding+ border + 内容 height = 盒子的高度 css positioning postion： 默认是 static relative 允许对元素的位置进行操作 absolute：相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。条件是定位基点（一般是父元素）不能是 static 定位， 否则定位基点是 html。 fixed：相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。 sticky：一些时候是 relative 定位（定位基点是自身默认位置），另一些时候自动变成 fixed 定位（定位基点是视口） 摘自：阮一峰教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css box model","slug":"css-box-model","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-box-model/"},{"name":"css positioning","slug":"css-positioning","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-positioning/"}]},{"title":"Redux middleware","slug":"3.2","date":"2020-03-02T07:57:48.000Z","updated":"2020-04-06T02:10:36.663Z","comments":true,"path":"2020/03/02/3.2/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/02/3.2/","excerpt":"","text":"redux 中间件 为什么要有中间件：目的是去处理一些在 redux 里的异步问题 store.dispath(action)是瞬时的，如果需要在 redux 里处理异步问题，则需要中间件来处理。 什么是中间件？（From Dan Abramov）It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. 实现一个异步功能的计数器？如果在 view 里有一个 button 的 onClick 事件，用户每次点击 button，则会触发 addOne action creator 并且可以 dispatch action；thunk 中间件允许我们 dispatch 出异步 function，它相比 reducers 是不纯净的；然后经过 thunk 中间件，再传递给 reducer 对 action 进行处理，生成全新的 state； 其与小点applyMiddlewares 作用是将所有中间件组成一个数组，依次执行，要注意中间件的次序；view 和 state 是一一对应的，当 state 变化，view 会被重新渲染；store.dispatch 方法会触发 Reducer 的自动执行；一个 action 可能经过不同的中间件，当 action 不需要再被处理时，中间件会进行自己的“熔断”机制；","categories":[],"tags":[{"name":"redux middleware","slug":"redux-middleware","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux-middleware/"}]},{"title":"事件捕获及冒泡","slug":"3.1","date":"2020-03-01T10:47:28.000Z","updated":"2020-03-17T11:33:06.253Z","comments":true,"path":"2020/03/01/3.1/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/01/3.1/","excerpt":"","text":"DOM 操作&amp;jQuery 在 jQuery 里必须是对 jQuery 对象进行操作，所以对象需要被包裹在$(obj)里,比如$(this.obj) 事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。即 child 事件先处理。但事件捕获(event capturing)与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。element.addEventListener(event, function, useCapture)true - 事件在捕获阶段执行false- 默认。事件在冒泡阶段执行 我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？非目标元素捕获 -&gt; 目标元素代码顺序 -&gt; 非目标元素冒泡https://blog.csdn.net/moguzhale/article/details/53503044 阻止冒泡和取消默认事件event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用 event.preventDefault()可以取消默认事件https://www.jianshu.com/p/1fd066b4c0ba","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"dom","slug":"dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"}]},{"title":"Redux middleware","slug":"2.29","date":"2020-02-29T10:23:43.000Z","updated":"2020-03-16T01:14:59.280Z","comments":true,"path":"2020/02/29/2.29/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/29/2.29/","excerpt":"","text":"redux 中间件 React 里 this 的指向问题谁调用的 this 就指向谁。eg:constructor 函数里的 this.state、生命周期函数等，这些函数都是由 react 实例来调用的。es6 箭头函数指向父层。eg：一个 onclick 函数；onclick={this.clickFunction} 这里的 this 是 undefined 的，所以在 clickFunction 里的 this 也是 undefined；有两种方法可以解决，第一种是将 clickFunction 变成箭头函数，箭头函数的 this 是指向父级作用域的，也就是 react 实例；第二种是使用 bind 改变 this 的指向。 redux 小点Redux 里 reducers 里的参数 state 要设置为空[ ]；每个 reducer(不同的 function)处理 state 的一个“片段”；const rootReducers = combineReducers({reducer 的集合})；connect 连接组件和 redux，返回一个 function开发时用来检查 state 对象是否被改变了 redux-immutable-state-invariant 插件；mapStateToProps 实现了让组件获取自己需要的 data，避免了全部渲染；如果没有加 mapdispatchtoprops, 组件实例会自动的把 dispatch 作为 props，允许我们 dispatch action，但需要添加类型检测， 1234import PropTypes from \"prop-types\";CoursesPage.propTypes = &#123; dispatch: PropTypes.func.isRequired&#125;; 渲染页面的流程 Js扩展运算符[…state,{object}] 合并 state 对象与 object 对象，如有重叠，将重叠的属性更新；exportexport default 对应着直接 import，不需要大括号，可以更改名字 ;export 需要{ }；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"Redux&JS","slug":"2.28","date":"2020-02-28T00:24:28.000Z","updated":"2020-03-07T14:44:59.330Z","comments":true,"path":"2020/02/28/2.28/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/28/2.28/","excerpt":"","text":"Redux React-Redux 将 react 组件绑定到 reduxhow?provider 组件将 app 连接到 redux storeconnect 组件将 react 组件连接到 redux store mapStateToProps去定义 store 里哪一部分 state 你想作为 props 传入；（确定可利用的 state）定义此函数时，组件会 subscribe redux store 的更新，每当 store 更新时，此函数会被调用；mapDispatchToProps去定义哪一 action 你想作为 props 传入给组件； Js把一个 object 和 function 相连，在 function 里的 this 代指这个 object，更改 this 的指向。 bindbind 会返回一个函数，但不会执行这个函数。var newFunc = functionName.bind(object)newFunc(argumentsOfFunction) callfunctionName.call(object,argumentsOfFunction) applyfunctionName.apply(object,arrayTypeArguments) 箭头函数与普通函数 this 指向this 永远指向的是最后调用它的对象new 关键字可以改变 this 的指向如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。普通函数 this 指向取决于函数调用的位置; 箭头函数 this 指向取决于函数定义的位置https://www.cnblogs.com/pssp/p/5216085.htmlhttps://zhuanlan.zhihu.com/p/47132493","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"React&JS","slug":"2.27","date":"2020-02-26T22:24:28.000Z","updated":"2020-03-08T04:02:11.070Z","comments":true,"path":"2020/02/27/2.27/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/27/2.27/","excerpt":"","text":"JS 异步函数 promise：https://juejin.im/post/5b605b035188251a90189c61 async-await:更简洁可读性更强的语法糖相比于 promisehttps://juejin.im/post/5b0399bc518825426f311a3e axios：是一个基于 promise 的 HTTP 库，简可以发送 get、post 请求等https://cloud.tencent.com/developer/article/1498443 youtube 搜索小应用 应用结构： searchBar 是搜索栏组件，videoDetails 是用户所搜索或者点击的视频组件，videoList 是右侧相关视频清单组件，videoItem 是右侧单个渲染视频组件；youtube 是向后台 api 发出请求。 应用界面： 整体流程：在 App.js 文件中渲染了 searchBar 组件，videoDetail 组件以及 videoList 组件，在 videoList 里渲染了 videoItem 组件。用户输入关键字，会显示首个视频以及右侧的清单；这是通过 App 组件向 searchBar 里传递的异步函数(获取 youtube 数据)，onSubmit 事件处理来调用此异步函数。用户点击右侧视频，会重新渲染页面；这是通过 App 组件向 videoList 里传递的 onVideoSelected 函数，再由 videoList 组件传递给 videoItem，最后再 videoItem 组件里 onClick 事件处理来调用这个 onVideoSelected 函数，在 onVideoSelected 函数会利用 setState 重新更改选择的视频，令 app 组件再次渲染。 整个项目要注意的是没有用 redux，导致传递 props 时最多经过了两个的组件，降低了可读性；在回调函数作为 props 时的处理问题；以及利用 async/await 从 youtube api 调取数据的流程，由 axios.create 创建实例等；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"promise","slug":"promise","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/promise/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"},{"name":"async-await","slug":"async-await","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/async-await/"},{"name":"axios","slug":"axios","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/axios/"}]},{"title":"React&JS","slug":"2.25","date":"2020-02-24T22:24:28.000Z","updated":"2020-03-07T14:50:23.374Z","comments":true,"path":"2020/02/25/2.25/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/25/2.25/","excerpt":"","text":"今天用 jQuery，bootstrap3.7.3，以及 GitHub api 做了一个小应用，主要是读取用户输入，再返回输入的 username 的基本信息，包括用户头像、followers、仓库等。 难点在于两次 ajax 的调用，第一次通过用户名获取用户的个人信息，第二次是在第一次结束之后再利用 url+/repos 来获取用户的最新仓库，用 each 方法来遍历整个 repos，再单个渲染；当 fetch 多个元素的时候，还要注意 jQuery append 的用法。另，html 里学会了 target=”_blank”，打开新页面的指令。总结：这次的 jQuery 来写的小程序让我了解了怎么在 jQuery 里用异步调用，以及 bootstrap 的常见 class。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"}]},{"title":"React&Redux","slug":"2.24","date":"2020-02-23T22:24:28.000Z","updated":"2020-03-16T01:08:18.864Z","comments":true,"path":"2020/02/24/2.24/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/24/2.24/","excerpt":"","text":"利用 webpack 来自定义开发环境，了解了 devServer，plugins，loader 的作用，如何在 package.json 里添加依赖等（还需再看，有些地方不是很理解）。 了解 Bable 的作用 （transpile JS to ECMA5）以及 eslint（代码规范）; React function 组件的好处：省掉 this 关键字；transpiled 后代码量更少；高信噪比等。 梳理了 Redux 知识点以及 React-Router 的用法：用于处理 复杂数据流、两个没有父子关系组件的交互、两个不同组件操作同样的内容、非分层的数据的情况。三个原理：不能直接改变 store；需要 action 作为 trigger；state 需要被纯函数（reducer）来处理流程图：actions are dispatched to reducers andreducers return a new state then cause the change of storestore let each components aware the change using CONNECT(React-Redux)reducers 可以看作绞肉机 每一次的 action 可以被多个 reducers 来 handle。为什么 Redux 要由不可变化的 store？提高了 performance 只需要对比旧 state 和新 state 的 memory reference 就知道是否变化；更加清晰 每次的改变知道在哪变化以及怎么变化；方便 debug。经过 reducer 的 action 返回的是一个新的 state，不会克隆内嵌元素，如果要拷贝整个 state，需要手动克隆内嵌对象（深拷贝）；但是深拷贝是降低 performance 的也是浪费的，只需要克隆已经改变的 object；还会造成不必要的渲染，react 会认为都变化了，但实际上只有子对象变化了。所以就是 redux 里的对比机制变相的提高了 performance。 容器组件和展示组件的区别。https://www.jianshu.com/p/6fa2b21f5df3 this 指向问题如果 this 所在的 function 是一个 obj 的方法时，则指向这个 obj；如果是属性，则指向父级作用域；如果 this 所在的 function 在全局环境里，则指向 window；如果 this 是在一个回调函数里，则指向 window（forEach 函数的第二个参数可以改变 this 指向）；如果 this 是在一个构造函数里，则指向 new 的实例对象（empty obj）；如果 this 在箭头函数（没有 this）里，则会指向父级作用域的 this 所指向的内容；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/webpack/"},{"name":"bable","slug":"bable","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/bable/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"react-router","slug":"react-router","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-router/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]}]}