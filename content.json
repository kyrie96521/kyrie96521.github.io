{"meta":{"title":"Kyle's Blog","subtitle":"","description":"","author":"Kyle Yang","url":"https://github.com/kyrie96521/kyrie96521.github.io","root":"/"},"pages":[{"title":"Tags","date":"2020-03-03T04:17:46.000Z","updated":"2020-03-04T00:44:53.835Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-03T08:30:00.000Z","updated":"2020-03-07T07:12:23.140Z","comments":true,"path":"about/index.html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/about/index.html","excerpt":"","text":"Record the leaning process of Kyle"}],"posts":[{"title":"Node","slug":"3.7","date":"2020-03-06T14:23:48.000Z","updated":"2020-03-07T14:52:01.490Z","comments":true,"path":"2020/03/07/3.7/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/07/3.7/","excerpt":"","text":"Node 为什么说 nodejs 是单线程语言呢？这是因为 nodejs 中 javascript 代码的执行是单线程；但 node 确实只有一个主线程，但是底层工作的线程却有多个。遇到异步时，主线程发出操作指令，然后就可以去做别的事情了（主线程不需要等待），所有操作完成后再执行回调。主线程什么时候知道操作完成执行回调，则通过 event loop 机制循环遍历。 nodejs 的异步 IO当需要 IO(网络 IO/文件 IO)操作时，单线程的 javascript 并不会停下来等待 IO 操作完成，而是“事件驱动”开始介入，javascript 执行线程继续执行未完的 javascript 代码，当执行完成后该线程处于空闲状态 事件循环Node.js 应用启动时，V8 引擎会执行你写的应用代码，保持一份观察者（注册在事件上的回调函数）列表。当事件发生时，它的回调函数会被加进一个事件队列。只要这个队列还有等待执行的回调函数，事件循环就会持续把回调函数从队列中拿出并执行。 4. 123456789//module 是一个 obj，有一个 exports 属性导出 function 或者 objmodule.exports.func = funcmodule.exports.endPoint = url (keep url private)require(\"./相对路径\")const path = require(\"path\")const pathObj = path.parse(\\_\\_filename)//包含 dir 地址，root，name 等属性const os = require(\"os\")//包含内存等等属性","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"node","slug":"node","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/node/"}]},{"title":"JS","slug":"3.6","date":"2020-03-05T14:23:48.000Z","updated":"2020-03-08T00:21:01.878Z","comments":true,"path":"2020/03/06/3.6/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/06/3.6/","excerpt":"","text":"JS 高阶函数123456789101112131415161718192021222324252627//forEach[1, 2, 3].forEach((item, index, arr) =&gt; &#123; //do something //handle in this array not a new array;&#125;);//mapconst newArr = [1, 2, 3].map((item, index, arr) =&gt; &#123; //do something //handle in a new array;&#125;);//filterconst evens = [1, 2, 3].filter((item, index) =&gt; &#123; //return true or false; //true will put the item back to the new array&#125;);//reduceconst evens = [1, 2, 3].reduce((prev, next) =&gt; &#123; //prev item and next item will do some kind of calculation; //return a number&#125;, randomNumAsStartNum);//some,every return true or false;//some: if any item satisfy the condition,return true//every: if all items satisfy the condition,return true","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"css grid","slug":"3.5","date":"2020-03-04T14:23:48.000Z","updated":"2020-03-08T00:21:01.878Z","comments":true,"path":"2020/03/05/3.5/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/05/3.5/","excerpt":"","text":"css grid grid 构成 Grid Container) 应用 display: grid 的元素网格项(Grid Item) 网格容器（Grid Container）的子元素（例如直接子元素）网格线(Grid Line) 网格轨道(Grid Track) 网格单元格(Grid Cell) 网格区域(Grid Area) grid 属性学习了各种网格容器属性以及网格项属性；两个教程：https://www.html.cn/archives/8510http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 网格容器与网格项结构 属性分为三大类：grid container;grid item;以及 grid 里的 content","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css grid","slug":"css-grid","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-grid/"}]},{"title":"css flex box","slug":"3.4","date":"2020-03-03T14:23:48.000Z","updated":"2020-03-07T14:45:57.918Z","comments":true,"path":"2020/03/04/3.4/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/04/3.4/","excerpt":"","text":"css flex box在 flex 布局中，flex 项（就是子元素）要么按照 main axis(主轴)（从 main-start 到 main-end ）排布，要么按照 cross axis(交叉轴) (从 cross-start 到 cross-end)排布。了解六个容器属性等。 两个极好的教程:https://www.html.cn/archives/8629https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css flex box","slug":"css-flex-box","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-flex-box/"}]},{"title":"css box model and positioning","slug":"3.3","date":"2020-03-03T01:57:48.000Z","updated":"2020-03-07T14:45:42.404Z","comments":true,"path":"2020/03/03/3.3/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/03/3.3/","excerpt":"","text":"css box model 所有元素在 css 里都会是一个 box； margin 是该 box 与其他 box 的距离，而 padding 是该盒子边界与内容区的距离 当两个 box 相邻时，margin 会塌陷（重叠），选 box margin 大的那一个作为距离 box-sizing 属性：border-box，内容区宽度或高度会自动调整padding + border + 内容 width= 盒子的宽度padding+ border + 内容 height = 盒子的高度 css positioning postion： 默认是 static relative 允许对元素的位置进行操作 absolute：相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。条件是定位基点（一般是父元素）不能是 static 定位， 否则定位基点是 html。 fixed：相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。 sticky：一些时候是 relative 定位（定位基点是自身默认位置），另一些时候自动变成 fixed 定位（定位基点是视口） 摘自：阮一峰教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css box model","slug":"css-box-model","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-box-model/"},{"name":"css positioning","slug":"css-positioning","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-positioning/"}]},{"title":"Redux middleware","slug":"3.2","date":"2020-03-02T07:57:48.000Z","updated":"2020-03-07T14:45:29.531Z","comments":true,"path":"2020/03/02/3.2/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/02/3.2/","excerpt":"","text":"redux 中间件 为什么要有中间件：目的是去处理一些在 redux 里的异步问题 store.dispath(action)是瞬时的，如果需要在 redux 里处理异步问题，则需要中间件来处理。 什么是中间件？（From Dan Abramov）It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. 实现一个异步功能的计数器？如果在 view 里有一个 button 的 onClick 事件，用户每次点击 button，则会触发 addOne action creator 并且可以 dispatch action；thunk 中间件允许我们 dispatch 出异步 function，它相比 reducers 是不纯净的；然后经过 thunk 中间件，再传递给 reducer 对 action 进行处理，生成全新的 state； 其与小点applyMiddlewares 作用是将所有中间件组成一个数组，依次执行，要注意中间件的次序；view 和 state 是一一对应的，当 state 变化，view 会被重新渲染；store.dispatch 方法会触发 Reducer 的自动执行；一个 action 可能经过不同的中间件，当 action 不需要再被处理时，中间件会进行自己的“熔断”机制；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux middleware","slug":"redux-middleware","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux-middleware/"}]},{"title":"事件捕获及冒泡","slug":"3.1","date":"2020-03-01T10:47:28.000Z","updated":"2020-03-07T14:45:21.006Z","comments":true,"path":"2020/03/01/3.1/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/01/3.1/","excerpt":"","text":"DOM 操作&amp;jQuery 在 jQuery 里必须是对 jQuery 对象进行操作，所以对象需要被包裹在$(obj)里,比如$(this.obj) 事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。即 child 事件先处理。但事件捕获(event capturing)与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。element.addEventListener(event, function, useCapture)true - 事件在捕获阶段执行false- 默认。事件在冒泡阶段执行 我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？非目标元素捕获 -&gt; 目标元素代码顺序 -&gt; 非目标元素冒泡https://blog.csdn.net/moguzhale/article/details/53503044 阻止冒泡和取消默认事件event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用 event.preventDefault()可以取消默认事件https://www.jianshu.com/p/1fd066b4c0ba","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"Dom","slug":"Dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Dom/"}]},{"title":"Redux middleware","slug":"2.29","date":"2020-02-29T10:23:43.000Z","updated":"2020-03-07T14:44:25.467Z","comments":true,"path":"2020/02/29/2.29/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/29/2.29/","excerpt":"","text":"redux 中间件 React 里 this 的指向问题谁调用的 this 就指向谁。eg:constructor 函数里的 this.state、生命周期函数等，这些函数都是由 react 实例来调用的。es6 箭头函数指向父层。eg：一个 onclick 函数；onclick={this.clickFunction} 这里的 this 是 undefined 的，所以在 clickFunction 里的 this 也是 undefined；有两种方法可以解决，第一种是将 clickFunction 变成箭头函数，箭头函数的 this 是指向父级作用域的，也就是 react 实例；第二种是使用 bind 改变 this 的指向。 redux 小点Redux 里 reducers 里的参数 state 要设置为空[ ]；每个 reducer(不同的 function)处理 state 的一个“片段”；const rootReducers = combineReducers({reducer 的集合})；connect 连接组件和 redux，返回一个 function开发时用来检查 state 对象是否被改变了 redux-immutable-state-invariant 插件；mapStateToProps 实现了让组件获取自己需要的 data，避免了全部渲染；如果没有加 mapdispatchtoprops, 组件实例会自动的把 dispatch 作为 props，允许我们 dispatch action，但需要添加类型检测， 1234import PropTypes from \"prop-types\";CoursesPage.propTypes = &#123; dispatch: PropTypes.func.isRequired&#125;; 渲染页面的流程 Js扩展运算符[…state,{object}] 合并 state 对象与 object 对象，如有重叠，将重叠的属性更新；exportexport default 对应着直接 import，不需要大括号，可以更改名字 ;export 需要{ }；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"}]},{"title":"Redux&JS","slug":"2.28","date":"2020-02-28T00:24:28.000Z","updated":"2020-03-07T14:44:59.330Z","comments":true,"path":"2020/02/28/2.28/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/28/2.28/","excerpt":"","text":"Redux React-Redux 将 react 组件绑定到 reduxhow?provider 组件将 app 连接到 redux storeconnect 组件将 react 组件连接到 redux store mapStateToProps去定义 store 里哪一部分 state 你想作为 props 传入；（确定可利用的 state）定义此函数时，组件会 subscribe redux store 的更新，每当 store 更新时，此函数会被调用；mapDispatchToProps去定义哪一 action 你想作为 props 传入给组件； Js把一个 object 和 function 相连，在 function 里的 this 代指这个 object，更改 this 的指向。 bindbind 会返回一个函数，但不会执行这个函数。var newFunc = functionName.bind(object)newFunc(argumentsOfFunction) callfunctionName.call(object,argumentsOfFunction) applyfunctionName.apply(object,arrayTypeArguments) 箭头函数与普通函数 this 指向this 永远指向的是最后调用它的对象new 关键字可以改变 this 的指向如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。普通函数 this 指向取决于函数调用的位置; 箭头函数 this 指向取决于函数定义的位置https://www.cnblogs.com/pssp/p/5216085.htmlhttps://zhuanlan.zhihu.com/p/47132493","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]},{"title":"React&JS","slug":"2.27","date":"2020-02-26T22:24:28.000Z","updated":"2020-03-08T04:02:11.070Z","comments":true,"path":"2020/02/27/2.27/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/27/2.27/","excerpt":"","text":"JS 异步函数 promise：https://juejin.im/post/5b605b035188251a90189c61 async-await:更简洁可读性更强的语法糖相比于 promisehttps://juejin.im/post/5b0399bc518825426f311a3e axios：是一个基于 promise 的 HTTP 库，简可以发送 get、post 请求等https://cloud.tencent.com/developer/article/1498443 youtube 搜索小应用 应用结构： searchBar 是搜索栏组件，videoDetails 是用户所搜索或者点击的视频组件，videoList 是右侧相关视频清单组件，videoItem 是右侧单个渲染视频组件；youtube 是向后台 api 发出请求。 应用界面： 整体流程：在 App.js 文件中渲染了 searchBar 组件，videoDetail 组件以及 videoList 组件，在 videoList 里渲染了 videoItem 组件。用户输入关键字，会显示首个视频以及右侧的清单；这是通过 App 组件向 searchBar 里传递的异步函数(获取 youtube 数据)，onSubmit 事件处理来调用此异步函数。用户点击右侧视频，会重新渲染页面；这是通过 App 组件向 videoList 里传递的 onVideoSelected 函数，再由 videoList 组件传递给 videoItem，最后再 videoItem 组件里 onClick 事件处理来调用这个 onVideoSelected 函数，在 onVideoSelected 函数会利用 setState 重新更改选择的视频，令 app 组件再次渲染。 整个项目要注意的是没有用 redux，导致传递 props 时最多经过了两个的组件，降低了可读性；在回调函数作为 props 时的处理问题；以及利用 async/await 从 youtube api 调取数据的流程，由 axios.create 创建实例等；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/promise/"},{"name":"async-await","slug":"async-await","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/async-await/"},{"name":"axios","slug":"axios","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/axios/"}]},{"title":"React&JS","slug":"2.25","date":"2020-02-24T22:24:28.000Z","updated":"2020-03-07T14:50:23.374Z","comments":true,"path":"2020/02/25/2.25/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/25/2.25/","excerpt":"","text":"今天用 jQuery，bootstrap3.7.3，以及 GitHub api 做了一个小应用，主要是读取用户输入，再返回输入的 username 的基本信息，包括用户头像、followers、仓库等。 难点在于两次 ajax 的调用，第一次通过用户名获取用户的个人信息，第二次是在第一次结束之后再利用 url+/repos 来获取用户的最新仓库，用 each 方法来遍历整个 repos，再单个渲染；当 fetch 多个元素的时候，还要注意 jQuery append 的用法。另，html 里学会了 target=”_blank”，打开新页面的指令。总结：这次的 jQuery 来写的小程序让我了解了怎么在 jQuery 里用异步调用，以及 bootstrap 的常见 class。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"}]},{"title":"React&Redux","slug":"2.24","date":"2020-02-23T22:24:28.000Z","updated":"2020-03-07T14:43:51.474Z","comments":true,"path":"2020/02/24/2.24/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/24/2.24/","excerpt":"","text":"利用 webpack 来自定义开发环境，了解了 devServer，plugins，loader 的作用，如何在 package.json 里添加依赖等（还需再看，有些地方不是很理解）。 了解 Bable 的作用 （transpile JS to ECMA5）以及 eslint（代码规范）; React function 组件的好处：省掉 this 关键字；transpiled 后代码量更少；高信噪比等。 梳理了 Redux 知识点以及 React-Router 的用法：用于处理 复杂数据流、两个没有父子关系组件的交互、两个不同组件操作同样的内容、非分层的数据的情况。三个原理：不能直接改变 store；需要 action 作为 trigger；state 需要被纯函数（reducer）来处理流程图：actions are dispatched to reducers andreducers return a new state then cause the change of storestore let each components aware the change using CONNECT(React-Redux)reducers 可以看作绞肉机 每一次的 action 可以被多个 reducers 来 handle。为什么 Redux 要由不可变化的 store？提高了 performance 只需要对比旧 state 和新 state 的 memory reference 就知道是否变化；更加清晰 每次的改变知道在哪变化以及怎么变化；方便 debug。经过 reducer 的 action 返回的是一个新的 state，不会克隆内嵌元素，如果要拷贝整个 state，需要手动克隆内嵌对象（深拷贝）；但是深拷贝是降低 performance 的也是浪费的，只需要克隆已经改变的 object；还会造成不必要的渲染，react 会认为都变化了，但实际上只有子对象变化了。所以就是 redux 里的对比机制变相的提高了 performance。 容器组件和展示组件的区别。https://www.jianshu.com/p/6fa2b21f5df3 this 指向问题如果 this 所在的 function 是一个 obj 的方法时，则指向这个 obj；如果是属性，则指向父级作用域；如果 this 所在的 function 在全局环境里，则指向 window；如果 this 是在一个回调函数里，则指向 window（forEach 函数的第二个参数可以改变 this 指向）；如果 this 是在一个构造函数里，则指向 new 的实例对象（empty obj）；如果 this 在箭头函数（没有 this）里，则会指向父级作用域的 this 所指向的内容；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/webpack/"},{"name":"Bable","slug":"Bable","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Bable/"},{"name":"React","slug":"React","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Redux/"},{"name":"React-Router","slug":"React-Router","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/React-Router/"}]}]}