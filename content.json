{"meta":{"title":"Kyle's Blog","subtitle":"","description":"","author":"Kyle Yang","url":"https://github.com/kyrie96521/kyrie96521.github.io","root":"/"},"pages":[{"title":"Tags","date":"2020-03-03T04:17:46.000Z","updated":"2020-03-04T00:44:53.835Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-03T08:30:00.000Z","updated":"2020-03-07T07:12:23.140Z","comments":true,"path":"about/index.html","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/about/index.html","excerpt":"","text":"Record the leaning process of Kyle"}],"posts":[{"title":"Scss","slug":"3.23","date":"2020-03-22T14:23:48.000Z","updated":"2020-03-28T05:04:57.212Z","comments":true,"path":"2020/03/23/3.23/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/23/3.23/","excerpt":"","text":"scss 变量用来存储需要在 CSS 中复用的信息，例如颜色和字体。 1234567$font-stack: Helvetica, sans-serif;$primary-color: #333;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 是过度的使用嵌套会让产生的 CSS 难以维护，因此是一种不好的实践 1234567891011nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125;&#125; SASS 能够将代码分割为多个片段，并以 underscore 风格的下划线作为其命名前缀,SASS 会通过这些下划线来辨别哪些文件是 SASS 片段，并且不让片段内容直接生成为 CSS 文件，从而只是在使用@import 指令的位置被导入. 1234567891011121314// _reset.scsshtml,body,ul,ol &#123; margin: 0; padding: 0;&#125;// base.scss@import \"reset\";body &#123; font: 100% Helvetica, sans-serif; background-color: #efefef;&#125; 混合（Mixin）用来分组那些需要在页面中复用的 CSS 声明，开发人员可以通过向 Mixin 传递变量参数来让代码更加灵活 12345678910@mixin border-radius($radius) &#123; border-radius: $radius; -ms-border-radius: $radius; -moz-border-radius: $radius; -webkit-border-radius: $radius;&#125;.box &#123; @include border-radius(10px);&#125; 上面的代码建立了一个名为 border-radius 的 Mixin，并传递了一个变量$radius 作为参数，然后在后续代码中通过@include border-radius(10px)使用该 Mixin，最终编译的结果如下： 123456.box &#123; border-radius: 10px; -ms-border-radius: 10px; -moz-border-radius: 10px; -webkit-border-radius: 10px;&#125; 继承是 SASS 中非常重要的一个特性，可以通过@extend 指令在选择器之间复用 CSS 属性，并且不会产生冗余的代码 12345678910111213141516171819202122232425262728293031// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。%other-styles &#123; display: flex; flex-wrap: wrap;&#125;// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。%message-common &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.message &#123; @extend %message-common;&#125;.success &#123; @extend %message-common; border-color: green;&#125;.error &#123; @extend %message-common; border-color: red;&#125;.warning &#123; @extend %message-common; border-color: yellow;&#125; 操作符SASS 提供了标准的算术运算符，例如+、-、*、/、%。 1234aside[role=\"complementary\"] &#123; float: right; width: 300px / 960px * 100%;&#125; Scss 允许 CSS 规则嵌套使用，父子规则将会呈现包含选择器的关系,可以避免重复的使用父级选择器，从而达到简化 CSS 代码结构的目的.Scss 使用$关键字在 CSS 规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下： 12345/*===== SCSS =====*/a &#123;font-weight: bold;text-decoration: none;&amp;:hover &#123; text-decoration: underline; &#125; Scss 当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"Scss","slug":"Scss","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Scss/"}]},{"title":"react","slug":"3.22","date":"2020-03-21T14:23:48.000Z","updated":"2020-03-28T05:04:57.212Z","comments":true,"path":"2020/03/22/3.22/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/22/3.22/","excerpt":"","text":"除了构造函数和生命周期钩子函数里会自动绑定 this 为当前组件外，其他的都不会自动绑定 this 的指向为当前组件。如果你在 JSX 里忘记将 this 绑定到 this.handleClick 并把它传入了 onClick，那么当你调用这个函数的时候 this 的值为 undefined。 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。 1&lt;span&gt;欢迎&#123;isQbVip &amp;&amp; &lt;a&gt;请尽快升级为正式 Vip!&lt;/a&gt;&#125;&lt;/span&gt; 如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]},{"title":"social network project","slug":"3.21","date":"2020-03-20T14:23:48.000Z","updated":"2020-03-27T10:54:07.709Z","comments":true,"path":"2020/03/21/3.21/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/21/3.21/","excerpt":"","text":"今天做的 project 内容是 express 对 server 的配置包括路由以及连接 MongoDB，让我对后端的结构有一个初步的理解。主要是以下几个点： 设置 PORT 环境变量并且告诉服务器去哪监听；若没有，本地在 5000 端口 。 1const PORT = process.env.PORT || 5000; app.use(/api/users, require(./routers/api/users));路由规则是 app.use(path,router)定义的，router 代表一个由 express.Router()创建的对象，在路由对象中可定义多个路由规则。每次将请求发送到服务器时，都会调用各个 app.use（middleware） app.use 和 app.get 的区别app.use(path,callback)中的 callback 既可以是 router 对象又可以是函数app.get(path,callback)中的 callback 只能是函数给 app.get(app.post、app.put 同理)赋个路由对象是不行的 获取 mongoURIcluster 连接自己的 app，设置安全地址等 mongodb 连接配置每次用 async 函数时，都要用 try-catch 函数来判断失败情况","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"}]},{"title":"backend staff","slug":"3.19","date":"2020-03-18T14:23:48.000Z","updated":"2020-03-28T05:04:57.211Z","comments":true,"path":"2020/03/19/3.19/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/19/3.19/","excerpt":"","text":"mongodbsharded cluster：同一个集合的不同子集分发存储到不同的机器（shard）上，Mongodb 使用 sharding 机制来支持超大数据量，将不同的 CRUD 路由到不同的机器上执行，提到了数据库的吞吐性能。collection：table 的集合。 Mongoose 是在 node.js 环境下对 mongodb 进行便捷操作的对象模型工具 AJAXAJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。Ajax 的工作原理相当于在用户和服务器之间加了一个中间层(ajax 引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给 Ajax 引擎自己来做, 只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求。把这些交给了 Ajax 引擎，用户操作起来也就感觉更加流畅了。 jQueryAJAX load 方法可以从服务器加载数据，并把返回的数据放入被选元素中 jQuery get()和 post()方法用于通过 HTTP GET 或 POST 请求从服务器请求数据 jQuery 提供了 children() 和 find() 方法用于向下遍历 DOM 树，以查找元素的后代。jQuery 提供了 parent() 、parents() 和 parentsUntil() 方法用于向上遍历 DOM 树，以查找元素的祖先。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/ajax/"},{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"}]},{"title":"Reat Hooks","slug":"3.18","date":"2020-03-17T14:23:48.000Z","updated":"2020-03-27T10:53:34.023Z","comments":true,"path":"2020/03/18/3.18/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/18/3.18/","excerpt":"","text":"todoList app加深了对 ES6，react hook，Jsx 的理解；useState(initialState) 可以接收新的 state 或者一个返回 state 的函数； 用 Hooks 实现生命周期每次 Render 都有自己的 Props 与 State。每次一 function 结束 rendering，useeffect 就会被调用。 format: useEffect(()=&gt;{}, [state])useEffect 会调用当 state 变化的时候，如果是空数组[],则 hook 不会被调用。 1234567fetch from Apiformat: useEffect(async ()=&gt;&#123;const response = await fetch(&amp;quot;url&amp;quot;);const data = await response.json();const [item] = data.results;setPerson(item);&#125;, [state]) DOM 操作DOM 就是浏览器为 JavaScript 提供的一系列接口，通过这些接口我们可以操作 web 页面。document.title 设置文档标题等价于 HTML 的 title 标签。innerHTML 与 outerHTML 的区别？innerHTML：内部 HTML，content；outerHTML：外部 HTML，content；innerText：内部文本，content ；outerText：内部文本，content ；摘自：React Hooks(2019)入门教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"dom","slug":"dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-hooks/"}]},{"title":"event-loop","slug":"3.15","date":"2020-03-14T14:23:48.000Z","updated":"2020-03-28T05:04:57.212Z","comments":true,"path":"2020/03/15/3.15/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/15/3.15/","excerpt":"","text":"jQuery 的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作. JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 异步任务指的是，不进入主线程、而进入任务队列（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。（3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 所谓回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，任务队列上第一位的事件就自动进入主线程。 ajax：可以在不重新加载整个网页的情况下，对网页的某部分进行更新。只要是 JS 调用异步通讯组件并使用格式化的数据来更新 web 页面上的内容或操作过程，那么我们用的方法就可算是 AJAX 摘自：阮一峰","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"event loop","slug":"event-loop","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/event-loop/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/ajax/"}]},{"title":"express","slug":"3.14","date":"2020-03-13T14:23:48.000Z","updated":"2020-03-16T01:30:15.645Z","comments":true,"path":"2020/03/14/3.14/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/14/3.14/","excerpt":"","text":"express 简介中间件：在 express 应用中，一切皆中间件。各种应用逻辑，如 cookie 解析、会话处理、日志记录、权限校验等，都是通过中间件来完成的。路由：负责寻址。比如用户发送了个 http 请求，该定位到哪个资源，就是路由说了算。模板引擎：负责视图动态渲染。 express.Router 模板引擎是一个将页面模板和数据结合起来生成 html 的工具。app.set(‘views’, path.join(__dirname, ‘views’))// 设置存放模板文件的目录app.set(‘view engine’, ‘ejs’)// 设置模板引擎为 ejs 通过调用 res.render 函数渲染 ejs 模板，res.render 第一个参数是模板的名字，这里是 users 则会匹配 views/users.ejs，第二个参数是传给模板的数据。用 includes 拆分模板组件通常有两个好处：模板可复用，减少重复代码主模板结构清晰 中间件与 nextexpress 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递，如内置的 res.render 其实就是渲染完 html 直接返回给客户端，没有调用 next()，从而没有传递给下一个中间件","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"}]},{"title":"react+redux 项目流程","slug":"3.13","date":"2020-03-12T14:23:48.000Z","updated":"2020-03-16T01:14:16.168Z","comments":true,"path":"2020/03/13/3.13/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/13/3.13/","excerpt":"","text":"restful Api 资源表现层状态转化资源是一种信息实体，它可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。如果客户端想要操作服务器，必须通过某种手段，让服务器端发生状态转化（State Transfer）。而这种转化是建立在表现层之上的，所以就是表现层状态转化。 react+redux 小项目流程 先 render 组件 componentDidMount (最常见的 fetch data 的地方就是在 componentDidMount 里) 1234567 componentDidMount() &#123; /*因为有 action 被发现 一被调用立即执行 dispatch function store.dispatch(fetchpost()); */ this.props.fetchPosts();&#125; action creator 对 api 请求负责初始化export default axios.create({baseURL: https://jsonplaceholder.typicode.com}); action creator 使用 axios 去做出 api 请求action 会被立刻 dispatch 被 reducers 执行，但是 api 请求是有 delay 的。所以需要异步 action creator，即中间件 redux-thunk 帮助我们能去完成发出请求的操作。 12345678910export const fetchPosts = () =&gt; &#123;return async (dispatch, getstate) =&gt; &#123;const response = await json.get(/posts);dispatch(&#123; type: FETCH_POSTS, payload: response.data &#125;);&#125;;&#125;;export const fetchUser = id =&gt; async dispatch =&gt; &#123;const response = await json.get(`/users/$&#123;id&#125;`);dispatch(&#123; type: FETCH_USER, payload: response.data &#125;);&#125;; async 函数返回值是 Promise 对象，给了我们获取 data 的权限。中间件：action creator 返回 function 或者 object，被 dispatch 到中间件，在中间件里会有 if 判断是 function 还是 object；如果是 obj，会直接到 reducers 里；如果是 function，会调用这个 function 以及 dispatch 和 getstate function。 api 返回 datadispatch({ type: FETCH_POSTS, payload: response.data }); action creator 返回一个带有 fetched data 的 action，dispatch 给 reducers。 reducer 接收 action 并且通过 payload 数据返回一个新 state。注意：必须返回除了 undefined 以外的值 []是可以的；state = null，第一次调用 state 默认是 null，表示现在没有被选择的值；第二次调用的时候，state 是由第一次 return 出来的 state 和 action2 产生。 12345678export default (state = [], action) =&gt; &#123; switch (action.type) &#123; case FETCH_USER: return [...state, action.payload]; default: return state; &#125;&#125;; 新的 state 会被作为 props 传入 react 组件，造成重新渲染。store 可以看作是 state 的集合。 1234const mapStateToProps = state =&gt; &#123; return &#123; posts: state.posts &#125;;&#125;;export default connect(mapStateToProps, &#123; fetchPosts &#125;)(PostList);","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"restful api","slug":"restful-api","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/restful-api/"}]},{"title":"Redux","slug":"3.12","date":"2020-03-11T14:23:48.000Z","updated":"2020-03-16T01:26:02.006Z","comments":true,"path":"2020/03/12/3.12/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/12/3.12/","excerpt":"","text":"Redux redux 作用？随着应用复杂度地不断提升，组件之间的状态通信变得越来越多，组件之间的耦合也变得越来越重。redux 能更好维护的模块间通信。 Redux 的单一状态树所有的 state 都以一个对象树的形式储存在一个单一的 store 中。页面中的所有状态 or 数据，都应该用这种状态树的形式来描述；页面上的任何变化，都应该先去改变这个状态树，然后再通过某种方式实现到页面上。 action 123456function changeText() &#123; return &#123; type: \"CHANGE_TEXT\", payload: \"Hello\" &#125;;&#125; Action 的任务是描述“发生了什么事情？”，这个函数会返回一个 Action 对象，这个对象里描述了“页面发生了什么”。随后这个对象会被传入到 Reducer 中。 reducer(state, action) =&gt; newStateReducer 的任务是根据传入的 Action 对象去修改状态树。Reducer 是一个纯函数， 根据传入的 当前 state 和 action ，返回一个新的 state 。 Storelet store = createStore(Reducer);state 是 store 的映射；Store 就是把 Reducer 和 action 联系到一起的对象。Store 有以下职责：维持应用的 state；提供 getState() 方法获取 state；提供 dispatch(action) 方法更新 state；通过 subscribe(listener) 注册监听器； 异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。中间件解决了这个问题。 什么是中间件？中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 摘自：阮一峰 知乎 er","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"}]},{"title":"express","slug":"3.11","date":"2020-03-10T14:23:48.000Z","updated":"2020-03-16T01:26:35.555Z","comments":true,"path":"2020/03/11/3.11/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/11/3.11/","excerpt":"","text":"express webpack 作用及流程component 必须返回 jsx，每次当 state 变化，组件重新渲染比如 webpack 会把 jsx 语句转化为 bundle.jswebpack 流程介绍 express 项目结构其中 app.js 是入口文件，views 文件夹下面放置的是需要渲染的模板文件，package.json 是整个项目的配置文件，.gitignore 文件里面写明文件 pull 到 github 时不需要上传的文件或文件夹，如 node_modules 文件夹。 app.js js 框架与模板引擎的区别模板引擎，就是将 HTML 模板渲染出最终样子的工具。把动态把数据填充到 HTML 里面，可以在服务器端做，也可以在浏览器端做比如 angular 会根据取到的数据去填充}里的内容，这是在客户端完成的。比如 JSP 会在服务器端去填充{$}里的内容，然后把最终的 html 送到浏览器，这是服务器端完成的。有时候前后端模板引擎会同时使用，即使有前端的模板引擎，后端返回 HTML 有时也是需要的，不仅仅返回是 JSON 数据区别：前后端分离可以大大将服务端的压力分散给客户端，而客户端的计算性能损耗几乎是微乎其微，并且在开发流程上，效率也极大提升，也可以适应敏捷开发。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"express","slug":"express","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"}]},{"title":"Webpack","slug":"3.10","date":"2020-03-09T14:23:48.000Z","updated":"2020-03-17T11:33:06.253Z","comments":true,"path":"2020/03/10/3.10/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/10/3.10/","excerpt":"","text":"Webpack 什么是 Webpack?WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。 为什要使用 WebPack?今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的 JavaScript 代码和一大堆依赖包。为了简化开发的复杂度，有不少好的实践方法a:模块化，让我们可以把复杂的程序细化为小的文件;b:类似于 TypeScript 这种在 JavaScript 基础上拓展的开发语言：使我们能够实现目前版本的 JavaScript 不能直接使用的特性，并且之后还能能装换为 JavaScript 文件使浏览器可以识别。 Webpack 的工作方式是?在 webpack 看来一切都是模块！他会把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个浏览器可识别的 JavaScript 文件。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/webpack/"}]},{"title":"React Hooks","slug":"3.9","date":"2020-03-08T14:23:48.000Z","updated":"2020-03-16T00:40:22.652Z","comments":true,"path":"2020/03/09/3.9/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/09/3.9/","excerpt":"","text":"react hook React 的核心思想是，一个 UI 组件响应一个 state 变化。 不使用 setState 更新 React 中的 state。React 组件不再是 ES6 class，它是一个纯粹而简单的 JavaScript 函数。const [buttonText, setButtonText] = useState(“Click me, please”);[state 值,state 更新函数] useEffect 获取数据替代 componentDidMount 在 React 中获取数据。useEffect 与 React 类中的 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途，但统一为单个 API。比如，在 useEffect 中调用 fetch。而且可以使用 setData（从 useState 中提取的更新函数）代替 this.setState。“useEffect 与 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途”componentDidUpdate！ componentDidUpdate 是一个生命周期方法，每当组件获得新的 props 或 state 发生变化时就会运行。如果直接调用 useEffect，你会看到无限循环。我们需要传递一个空数组作为 useEffect 的第二个参数：[]。 12345useEffect(() =&gt; &#123; fetch(\"http://localhost:3001/links/\") .then(response =&gt; response.json()) .then(data =&gt; setData(data));&#125;, []); 使用带有 React Hooks 的 render props 吗？没有意义。那是因为 React Hooks 诞生的原因的：在组件之间共享逻辑。有了一个标准的、干净的方式来封装和共享逻辑。 可以在 useEffect 中使用 async/await 吗?不能直接使用。那是因为 JavaScript 异步函数总是返回一个 promise，而 useEffect 只能返回另一个函数。如果你要在 useEffect 中使用 setInterval 定时器，我们应该返回一个函数（闭包）来清除 setInterval。 摘自：React Hooks(2019)入门教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react hooks","slug":"react-hooks","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-hooks/"}]},{"title":"git","slug":"3.8","date":"2020-03-07T14:23:48.000Z","updated":"2020-03-10T05:44:07.970Z","comments":true,"path":"2020/03/08/3.8/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/08/3.8/","excerpt":"","text":"今天算是做完了 9321 的第一个 assignment，考察了对 python 里几个包的运用，pandas、matplotlib 等，主要是用 python 进行数据处理和可视化，还是蛮简单的。 顺便记录一下 git 的基本操作。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"unsw","slug":"unsw","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/unsw/"},{"name":"git","slug":"git","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/git/"}]},{"title":"Node","slug":"3.7","date":"2020-03-06T14:23:48.000Z","updated":"2020-03-07T14:52:01.490Z","comments":true,"path":"2020/03/07/3.7/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/07/3.7/","excerpt":"","text":"Node 为什么说 nodejs 是单线程语言呢？这是因为 nodejs 中 javascript 代码的执行是单线程；但 node 确实只有一个主线程，但是底层工作的线程却有多个。遇到异步时，主线程发出操作指令，然后就可以去做别的事情了（主线程不需要等待），所有操作完成后再执行回调。主线程什么时候知道操作完成执行回调，则通过 event loop 机制循环遍历。 nodejs 的异步 IO当需要 IO(网络 IO/文件 IO)操作时，单线程的 javascript 并不会停下来等待 IO 操作完成，而是“事件驱动”开始介入，javascript 执行线程继续执行未完的 javascript 代码，当执行完成后该线程处于空闲状态 事件循环Node.js 应用启动时，V8 引擎会执行你写的应用代码，保持一份观察者（注册在事件上的回调函数）列表。当事件发生时，它的回调函数会被加进一个事件队列。只要这个队列还有等待执行的回调函数，事件循环就会持续把回调函数从队列中拿出并执行。 4. 123456789//module 是一个 obj，有一个 exports 属性导出 function 或者 objmodule.exports.func = funcmodule.exports.endPoint = url (keep url private)require(\"./相对路径\")const path = require(\"path\")const pathObj = path.parse(\\_\\_filename)//包含 dir 地址，root，name 等属性const os = require(\"os\")//包含内存等等属性","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"node","slug":"node","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/node/"}]},{"title":"JS","slug":"3.6","date":"2020-03-05T14:23:48.000Z","updated":"2020-03-08T00:21:01.878Z","comments":true,"path":"2020/03/06/3.6/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/06/3.6/","excerpt":"","text":"JS 高阶函数123456789101112131415161718192021222324252627//forEach[1, 2, 3].forEach((item, index, arr) =&gt; &#123; //do something //handle in this array not a new array;&#125;);//mapconst newArr = [1, 2, 3].map((item, index, arr) =&gt; &#123; //do something //handle in a new array;&#125;);//filterconst evens = [1, 2, 3].filter((item, index) =&gt; &#123; //return true or false; //true will put the item back to the new array&#125;);//reduceconst evens = [1, 2, 3].reduce((prev, next) =&gt; &#123; //prev item and next item will do some kind of calculation; //return a number&#125;, randomNumAsStartNum);//some,every return true or false;//some: if any item satisfy the condition,return true//every: if all items satisfy the condition,return true","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"css grid","slug":"3.5","date":"2020-03-04T14:23:48.000Z","updated":"2020-03-08T00:21:01.878Z","comments":true,"path":"2020/03/05/3.5/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/05/3.5/","excerpt":"","text":"css grid grid 构成 Grid Container) 应用 display: grid 的元素网格项(Grid Item) 网格容器（Grid Container）的子元素（例如直接子元素）网格线(Grid Line) 网格轨道(Grid Track) 网格单元格(Grid Cell) 网格区域(Grid Area) grid 属性学习了各种网格容器属性以及网格项属性；两个教程：https://www.html.cn/archives/8510http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html 网格容器与网格项结构 属性分为三大类：grid container;grid item;以及 grid 里的 content","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css grid","slug":"css-grid","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-grid/"}]},{"title":"css flex box","slug":"3.4","date":"2020-03-03T14:23:48.000Z","updated":"2020-03-16T01:14:46.576Z","comments":true,"path":"2020/03/04/3.4/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/04/3.4/","excerpt":"","text":"css flex box在 flex 布局中，flex 项（就是子元素）要么按照 main axis(主轴)（从 main-start 到 main-end ）排布，要么按照 cross axis(交叉轴) (从 cross-start 到 cross-end)排布。了解六个容器属性等。 两个极好的教程:CSS3 Flexbox 布局完全指南阮一峰","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css flex box","slug":"css-flex-box","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-flex-box/"}]},{"title":"css box model and positioning","slug":"3.3","date":"2020-03-03T01:57:48.000Z","updated":"2020-03-07T14:45:42.404Z","comments":true,"path":"2020/03/03/3.3/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/03/3.3/","excerpt":"","text":"css box model 所有元素在 css 里都会是一个 box； margin 是该 box 与其他 box 的距离，而 padding 是该盒子边界与内容区的距离 当两个 box 相邻时，margin 会塌陷（重叠），选 box margin 大的那一个作为距离 box-sizing 属性：border-box，内容区宽度或高度会自动调整padding + border + 内容 width= 盒子的宽度padding+ border + 内容 height = 盒子的高度 css positioning postion： 默认是 static relative 允许对元素的位置进行操作 absolute：相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。条件是定位基点（一般是父元素）不能是 static 定位， 否则定位基点是 html。 fixed：相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。 sticky：一些时候是 relative 定位（定位基点是自身默认位置），另一些时候自动变成 fixed 定位（定位基点是视口） 摘自：阮一峰教程","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"css box model","slug":"css-box-model","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-box-model/"},{"name":"css positioning","slug":"css-positioning","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/css-positioning/"}]},{"title":"Redux middleware","slug":"3.2","date":"2020-03-02T07:57:48.000Z","updated":"2020-03-07T14:45:29.531Z","comments":true,"path":"2020/03/02/3.2/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/02/3.2/","excerpt":"","text":"redux 中间件 为什么要有中间件：目的是去处理一些在 redux 里的异步问题 store.dispath(action)是瞬时的，如果需要在 redux 里处理异步问题，则需要中间件来处理。 什么是中间件？（From Dan Abramov）It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. 实现一个异步功能的计数器？如果在 view 里有一个 button 的 onClick 事件，用户每次点击 button，则会触发 addOne action creator 并且可以 dispatch action；thunk 中间件允许我们 dispatch 出异步 function，它相比 reducers 是不纯净的；然后经过 thunk 中间件，再传递给 reducer 对 action 进行处理，生成全新的 state； 其与小点applyMiddlewares 作用是将所有中间件组成一个数组，依次执行，要注意中间件的次序；view 和 state 是一一对应的，当 state 变化，view 会被重新渲染；store.dispatch 方法会触发 Reducer 的自动执行；一个 action 可能经过不同的中间件，当 action 不需要再被处理时，中间件会进行自己的“熔断”机制；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux middleware","slug":"redux-middleware","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux-middleware/"}]},{"title":"事件捕获及冒泡","slug":"3.1","date":"2020-03-01T10:47:28.000Z","updated":"2020-03-17T11:33:06.253Z","comments":true,"path":"2020/03/01/3.1/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/03/01/3.1/","excerpt":"","text":"DOM 操作&amp;jQuery 在 jQuery 里必须是对 jQuery 对象进行操作，所以对象需要被包裹在$(obj)里,比如$(this.obj) 事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。即 child 事件先处理。但事件捕获(event capturing)与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。element.addEventListener(event, function, useCapture)true - 事件在捕获阶段执行false- 默认。事件在冒泡阶段执行 我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？非目标元素捕获 -&gt; 目标元素代码顺序 -&gt; 非目标元素冒泡https://blog.csdn.net/moguzhale/article/details/53503044 阻止冒泡和取消默认事件event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用 event.preventDefault()可以取消默认事件https://www.jianshu.com/p/1fd066b4c0ba","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"dom","slug":"dom","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"}]},{"title":"Redux middleware","slug":"2.29","date":"2020-02-29T10:23:43.000Z","updated":"2020-03-16T01:14:59.280Z","comments":true,"path":"2020/02/29/2.29/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/29/2.29/","excerpt":"","text":"redux 中间件 React 里 this 的指向问题谁调用的 this 就指向谁。eg:constructor 函数里的 this.state、生命周期函数等，这些函数都是由 react 实例来调用的。es6 箭头函数指向父层。eg：一个 onclick 函数；onclick={this.clickFunction} 这里的 this 是 undefined 的，所以在 clickFunction 里的 this 也是 undefined；有两种方法可以解决，第一种是将 clickFunction 变成箭头函数，箭头函数的 this 是指向父级作用域的，也就是 react 实例；第二种是使用 bind 改变 this 的指向。 redux 小点Redux 里 reducers 里的参数 state 要设置为空[ ]；每个 reducer(不同的 function)处理 state 的一个“片段”；const rootReducers = combineReducers({reducer 的集合})；connect 连接组件和 redux，返回一个 function开发时用来检查 state 对象是否被改变了 redux-immutable-state-invariant 插件；mapStateToProps 实现了让组件获取自己需要的 data，避免了全部渲染；如果没有加 mapdispatchtoprops, 组件实例会自动的把 dispatch 作为 props，允许我们 dispatch action，但需要添加类型检测， 1234import PropTypes from \"prop-types\";CoursesPage.propTypes = &#123; dispatch: PropTypes.func.isRequired&#125;; 渲染页面的流程 Js扩展运算符[…state,{object}] 合并 state 对象与 object 对象，如有重叠，将重叠的属性更新；exportexport default 对应着直接 import，不需要大括号，可以更改名字 ;export 需要{ }；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"Redux&JS","slug":"2.28","date":"2020-02-28T00:24:28.000Z","updated":"2020-03-07T14:44:59.330Z","comments":true,"path":"2020/02/28/2.28/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/28/2.28/","excerpt":"","text":"Redux React-Redux 将 react 组件绑定到 reduxhow?provider 组件将 app 连接到 redux storeconnect 组件将 react 组件连接到 redux store mapStateToProps去定义 store 里哪一部分 state 你想作为 props 传入；（确定可利用的 state）定义此函数时，组件会 subscribe redux store 的更新，每当 store 更新时，此函数会被调用；mapDispatchToProps去定义哪一 action 你想作为 props 传入给组件； Js把一个 object 和 function 相连，在 function 里的 this 代指这个 object，更改 this 的指向。 bindbind 会返回一个函数，但不会执行这个函数。var newFunc = functionName.bind(object)newFunc(argumentsOfFunction) callfunctionName.call(object,argumentsOfFunction) applyfunctionName.apply(object,arrayTypeArguments) 箭头函数与普通函数 this 指向this 永远指向的是最后调用它的对象new 关键字可以改变 this 的指向如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。普通函数 this 指向取决于函数调用的位置; 箭头函数 this 指向取决于函数定义的位置https://www.cnblogs.com/pssp/p/5216085.htmlhttps://zhuanlan.zhihu.com/p/47132493","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"}]},{"title":"React&JS","slug":"2.27","date":"2020-02-26T22:24:28.000Z","updated":"2020-03-08T04:02:11.070Z","comments":true,"path":"2020/02/27/2.27/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/27/2.27/","excerpt":"","text":"JS 异步函数 promise：https://juejin.im/post/5b605b035188251a90189c61 async-await:更简洁可读性更强的语法糖相比于 promisehttps://juejin.im/post/5b0399bc518825426f311a3e axios：是一个基于 promise 的 HTTP 库，简可以发送 get、post 请求等https://cloud.tencent.com/developer/article/1498443 youtube 搜索小应用 应用结构： searchBar 是搜索栏组件，videoDetails 是用户所搜索或者点击的视频组件，videoList 是右侧相关视频清单组件，videoItem 是右侧单个渲染视频组件；youtube 是向后台 api 发出请求。 应用界面： 整体流程：在 App.js 文件中渲染了 searchBar 组件，videoDetail 组件以及 videoList 组件，在 videoList 里渲染了 videoItem 组件。用户输入关键字，会显示首个视频以及右侧的清单；这是通过 App 组件向 searchBar 里传递的异步函数(获取 youtube 数据)，onSubmit 事件处理来调用此异步函数。用户点击右侧视频，会重新渲染页面；这是通过 App 组件向 videoList 里传递的 onVideoSelected 函数，再由 videoList 组件传递给 videoItem，最后再 videoItem 组件里 onClick 事件处理来调用这个 onVideoSelected 函数，在 onVideoSelected 函数会利用 setState 重新更改选择的视频，令 app 组件再次渲染。 整个项目要注意的是没有用 redux，导致传递 props 时最多经过了两个的组件，降低了可读性；在回调函数作为 props 时的处理问题；以及利用 async/await 从 youtube api 调取数据的流程，由 axios.create 创建实例等；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"},{"name":"promise","slug":"promise","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/promise/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"},{"name":"async-await","slug":"async-await","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/async-await/"},{"name":"axios","slug":"axios","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/axios/"}]},{"title":"React&JS","slug":"2.25","date":"2020-02-24T22:24:28.000Z","updated":"2020-03-07T14:50:23.374Z","comments":true,"path":"2020/02/25/2.25/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/25/2.25/","excerpt":"","text":"今天用 jQuery，bootstrap3.7.3，以及 GitHub api 做了一个小应用，主要是读取用户输入，再返回输入的 username 的基本信息，包括用户头像、followers、仓库等。 难点在于两次 ajax 的调用，第一次通过用户名获取用户的个人信息，第二次是在第一次结束之后再利用 url+/repos 来获取用户的最新仓库，用 each 方法来遍历整个 repos，再单个渲染；当 fetch 多个元素的时候，还要注意 jQuery append 的用法。另，html 里学会了 target=”_blank”，打开新页面的指令。总结：这次的 jQuery 来写的小程序让我了解了怎么在 jQuery 里用异步调用，以及 bootstrap 的常见 class。","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"},{"name":"project","slug":"project","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"}]},{"title":"React&Redux","slug":"2.24","date":"2020-02-23T22:24:28.000Z","updated":"2020-03-16T01:08:18.864Z","comments":true,"path":"2020/02/24/2.24/","link":"","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/2020/02/24/2.24/","excerpt":"","text":"利用 webpack 来自定义开发环境，了解了 devServer，plugins，loader 的作用，如何在 package.json 里添加依赖等（还需再看，有些地方不是很理解）。 了解 Bable 的作用 （transpile JS to ECMA5）以及 eslint（代码规范）; React function 组件的好处：省掉 this 关键字；transpiled 后代码量更少；高信噪比等。 梳理了 Redux 知识点以及 React-Router 的用法：用于处理 复杂数据流、两个没有父子关系组件的交互、两个不同组件操作同样的内容、非分层的数据的情况。三个原理：不能直接改变 store；需要 action 作为 trigger；state 需要被纯函数（reducer）来处理流程图：actions are dispatched to reducers andreducers return a new state then cause the change of storestore let each components aware the change using CONNECT(React-Redux)reducers 可以看作绞肉机 每一次的 action 可以被多个 reducers 来 handle。为什么 Redux 要由不可变化的 store？提高了 performance 只需要对比旧 state 和新 state 的 memory reference 就知道是否变化；更加清晰 每次的改变知道在哪变化以及怎么变化；方便 debug。经过 reducer 的 action 返回的是一个新的 state，不会克隆内嵌元素，如果要拷贝整个 state，需要手动克隆内嵌对象（深拷贝）；但是深拷贝是降低 performance 的也是浪费的，只需要克隆已经改变的 object；还会造成不必要的渲染，react 会认为都变化了，但实际上只有子对象变化了。所以就是 redux 里的对比机制变相的提高了 performance。 容器组件和展示组件的区别。https://www.jianshu.com/p/6fa2b21f5df3 this 指向问题如果 this 所在的 function 是一个 obj 的方法时，则指向这个 obj；如果是属性，则指向父级作用域；如果 this 所在的 function 在全局环境里，则指向 window；如果 this 是在一个回调函数里，则指向 window（forEach 函数的第二个参数可以改变 this 指向）；如果 this 是在一个构造函数里，则指向 new 的实例对象（empty obj）；如果 this 在箭头函数（没有 this）里，则会指向父级作用域的 this 所指向的内容；","categories":[],"tags":[{"name":"Daily juice","slug":"Daily-juice","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/webpack/"},{"name":"bable","slug":"bable","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/bable/"},{"name":"react","slug":"react","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"},{"name":"react-router","slug":"react-router","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/react-router/"},{"name":"this","slug":"this","permalink":"https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"}]}]}