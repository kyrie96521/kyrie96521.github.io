<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kyle&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/kyrie96521/kyrie96521.github.io/"/>
  <updated>2020-03-28T05:04:57.212Z</updated>
  <id>https://github.com/kyrie96521/kyrie96521.github.io/</id>
  
  <author>
    <name>Kyle Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scss</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/23/3.23/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/23/3.23/</id>
    <published>2020-03-22T14:23:48.000Z</published>
    <updated>2020-03-28T05:04:57.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a><a href="https://zhuanlan.zhihu.com/p/35478792" target="_blank" rel="noopener">scss</a></h3><ol><li>变量用来存储需要在 CSS 中复用的信息，例如颜色和字体。</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>是过度的使用嵌套会让产生的 CSS 难以维护，因此是一种不好的实践</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>SASS 能够将代码分割为多个片段，并以 underscore 风格的下划线作为其命名前缀,SASS 会通过这些下划线来辨别哪些文件是 SASS 片段，并且不让片段内容直接生成为 CSS 文件，从而只是在使用@import 指令的位置被导入.</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _reset.scss</span></span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// base.scss</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"reset"</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span> Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>混合（Mixin）用来分组那些需要在页面中复用的 CSS 声明，开发人员可以通过向 Mixin 传递变量参数来让代码更加灵活</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>) &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-radius(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码建立了一个名为 border-radius 的 Mixin，并传递了一个变量$radius 作为参数，然后在后续代码中通过@include border-radius(10px)使用该 Mixin，最终编译的结果如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>继承是 SASS 中非常重要的一个特性，可以通过@extend 指令在选择器之间复用 CSS 属性，并且不会产生冗余的代码</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。</span></span><br><span class="line">%other-styles &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。</span></span><br><span class="line">%message-common &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %message-common;</span><br><span class="line">  <span class="attribute">border-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>操作符<br>SASS 提供了标准的算术运算符，例如+、-、*、/、%。</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role="complementary"]</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>Scss 允许 CSS 规则嵌套使用，父子规则将会呈现包含选择器的关系,可以避免重复的使用父级选择器，从而达到简化 CSS 代码结构的目的.<br>Scss 使用$关键字在 CSS 规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===== SCSS =====*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line">&amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>Scss 当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;scss&quot;&gt;&lt;a href=&quot;#scss&quot; class=&quot;headerlink&quot; title=&quot;scss&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35478792&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="Scss" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Scss/"/>
    
  </entry>
  
  <entry>
    <title>react</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/22/3.22/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/22/3.22/</id>
    <published>2020-03-21T14:23:48.000Z</published>
    <updated>2020-03-28T05:04:57.212Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>除了构造函数和生命周期钩子函数里会自动绑定 this 为当前组件外，其他的都不会自动绑定 <a href="https://sunburst.wang/posts/2019/07/05/react-docs-notes.html#_1-%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">this 的指向</a>为当前组件。<br>如果你在 JSX 里忘记将 this 绑定到 this.handleClick 并把它传入了 onClick，那么当你调用这个函数的时候 this 的值为 undefined。</p></li><li><p>React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>欢迎&#123;isQbVip &amp;&amp; <span class="tag">&lt;<span class="name">a</span>&gt;</span>请尽快升级为正式 Vip!<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;除了构造函数和生命周期钩子函数里会自动绑定 this 为当前组件外，其他的都不会自动绑定 &lt;a href=&quot;https://sunburst.wang/posts/2019/07/05/react-docs-notes.html#_1-%E5%85%83%
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="react" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"/>
    
      <category term="this" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>social network project</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/21/3.21/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/21/3.21/</id>
    <published>2020-03-20T14:23:48.000Z</published>
    <updated>2020-03-27T10:54:07.709Z</updated>
    
    <content type="html"><![CDATA[<p>今天做的 project 内容是 express 对 server 的配置包括路由以及连接 MongoDB，让我对后端的结构有一个初步的理解。主要是以下几个点：</p><ol><li>设置 PORT 环境变量并且告诉服务器去哪监听；若没有，本地在 5000 端口 。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || <span class="number">5000</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>app.use(/api/users, require(./routers/api/users));<br>路由规则是 app.use(path,router)定义的，router 代表一个由 express.Router()创建的对象，在路由对象中可定义多个路由规则。每次将请求发送到服务器时，都会调用各个 app.use（middleware）</p></li><li><p><a href="https://blog.csdn.net/wthfeng/article/details/53366169" target="_blank" rel="noopener">app.use 和 app.get 的区别</a><br>app.use(path,callback)中的 callback 既可以是 router 对象又可以是函数<br>app.get(path,callback)中的 callback 只能是函数<br>给 app.get(app.post、app.put 同理)赋个路由对象是不行的</p></li><li><p>获取 mongoURI<br>cluster 连接自己的 app，设置安全地址等</p></li><li><p>mongodb 连接配置<br>每次用 async 函数时，都要用 try-catch 函数来判断失败情况</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天做的 project 内容是 express 对 server 的配置包括路由以及连接 MongoDB，让我对后端的结构有一个初步的理解。主要是以下几个点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 PORT 环境变量并且告诉服务器去哪监听；若没有，本地在 5000 端口 。&lt;/
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="project" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"/>
    
      <category term="express" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"/>
    
      <category term="mongodb" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>backend staff</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/19/3.19/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/19/3.19/</id>
    <published>2020-03-18T14:23:48.000Z</published>
    <updated>2020-03-28T05:04:57.211Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>mongodb<br>sharded cluster：同一个集合的不同子集分发存储到不同的机器（shard）上，Mongodb 使用 sharding 机制来支持超大数据量，将不同的 CRUD 路由到不同的机器上执行，提到了数据库的吞吐性能。<br>collection：table 的集合。</p></li><li><p>Mongoose 是在 node.js 环境下对 mongodb 进行便捷操作的对象模型工具</p></li><li><p>AJAX<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。<br><a href="https://juejin.im/post/587f8dbd570c3522011c0f59" target="_blank" rel="noopener">Ajax 的工作原理</a>相当于在用户和服务器之间加了一个中间层(ajax 引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给 Ajax 引擎自己来做, 只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求。把这些交给了 Ajax 引擎，用户操作起来也就感觉更加流畅了。</p></li><li><p>jQuery<br><a href="https://www.twle.cn/l/yufei/jquery/jquery-basic-ajax-load.html" target="_blank" rel="noopener">AJAX load</a> 方法可以从服务器加载数据，并把返回的数据放入被选元素中</p><p>jQuery <a href="https://www.twle.cn/l/yufei/jquery/jquery-basic-ajax-get-post.html" target="_blank" rel="noopener">get()和 post()方法</a>用于通过 HTTP GET 或 POST 请求从服务器请求数据</p><p>jQuery 提供了 children() 和 find() 方法用于向下遍历 DOM 树，以查找元素的后代。<br>jQuery 提供了 parent() 、parents() 和 parentsUntil() 方法用于向上遍历 DOM 树，以查找元素的祖先。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;mongodb&lt;br&gt;sharded cluster：同一个集合的不同子集分发存储到不同的机器（shard）上，Mongodb 使用 sharding 机制来支持超大数据量，将不同的 CRUD 路由到不同的机器上执行，提到了数据库的吞吐性能。&lt;br&gt;col
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="jquery" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"/>
    
      <category term="ajax" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/ajax/"/>
    
      <category term="mongodb" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Reat Hooks</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/18/3.18/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/18/3.18/</id>
    <published>2020-03-17T14:23:48.000Z</published>
    <updated>2020-03-27T10:53:34.023Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>todoList app<br>加深了对 ES6，react hook，Jsx 的理解；<br>useState(initialState) 可以接收新的 state 或者一个返回 state 的函数；</p></li><li><p>用 Hooks 实现生命周期<br>每次 Render 都有自己的 Props 与 State。<br>每次一 function 结束 rendering，useeffect 就会被调用。</p><p>format: useEffect(()=&gt;{}, [state])<br>useEffect 会调用当 state 变化的时候，如果是空数组[],则 hook 不会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch <span class="keyword">from</span> Api</span><br><span class="line">format: useEffect(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(&amp;quot;url&amp;quot;);</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"><span class="keyword">const</span> [item] = data.results;</span><br><span class="line">setPerson(item);</span><br><span class="line">&#125;, [state])</span><br></pre></td></tr></table></figure></li><li><p>DOM 操作<br>DOM 就是浏览器为 JavaScript 提供的一系列接口，通过这些接口我们可以操作 web 页面。<br>document.title 设置文档标题等价于 HTML 的 title 标签。<br>innerHTML 与 outerHTML 的区别？<br>innerHTML：内部 HTML，content<br/>；<br>outerHTML：外部 HTML，<div>content<br/></div>；<br>innerText：内部文本，content ；<br>outerText：内部文本，content ；<br><img src="/images/html.jpg" alt=""><br>摘自：<a href="https://fenews.org/posts/getting-started-with-react-hooks/" target="_blank" rel="noopener">React Hooks(2019)入门教程</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;todoList app&lt;br&gt;加深了对 ES6，react hook，Jsx 的理解；&lt;br&gt;useState(initialState) 可以接收新的 state 或者一个返回 state 的函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用 Hooks 实
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="project" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/project/"/>
    
      <category term="dom" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"/>
    
      <category term="react hooks" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/react-hooks/"/>
    
  </entry>
  
  <entry>
    <title>event-loop</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/15/3.15/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/15/3.15/</id>
    <published>2020-03-14T14:23:48.000Z</published>
    <updated>2020-03-28T05:04:57.212Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>jQuery 的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作.</p></li><li><p>JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p></li><li><p>异步任务指的是，不进入主线程、而进入任务队列（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。<br>（3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。<br><img src="/images/eventloop.jpg" alt=""></p></li><li><p>所谓回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。<br>任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，任务队列上第一位的事件就自动进入主线程。</p></li><li><p>ajax：可以在不重新加载整个网页的情况下，对网页的某部分进行更新。只要是 JS 调用异步通讯组件并使用格式化的数据来更新 web 页面上的内容或操作过程，那么我们用的方法就可算是 AJAX</p></li></ol><p>摘自：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;jQuery 的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。JavaScript 的主要用途是与用户互动，以及操作 DOM。
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="jquery" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/jquery/"/>
    
      <category term="event loop" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/event-loop/"/>
    
      <category term="ajax" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/14/3.14/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/14/3.14/</id>
    <published>2020-03-13T14:23:48.000Z</published>
    <updated>2020-03-16T01:30:15.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><ol><li><p>简介<br>中间件：在 express 应用中，一切皆中间件。各种应用逻辑，如 cookie 解析、会话处理、日志记录、权限校验等，都是通过中间件来完成的。<br>路由：负责寻址。比如用户发送了个 http 请求，该定位到哪个资源，就是路由说了算。<br>模板引擎：负责视图动态渲染。</p></li><li><p><a href="https://github.scom/nswbmw/N-blog/blob/master/book/3.2%20%E8%B7%AF%E7%94%B1.md/" target="_blank" rel="noopener">express.Router</a></p></li><li><p>模板引擎是一个将页面模板和数据结合起来生成 html 的工具。<br>app.set(‘views’, path.join(__dirname, ‘views’))// 设置存放模板文件的目录<br>app.set(‘view engine’, ‘ejs’)// 设置模板引擎为 ejs</p><p>通过调用 res.render 函数渲染 ejs 模板，res.render 第一个参数是模板的名字，这里是 users 则会匹配 views/users.ejs，第二个参数是传给模板的数据。<br>用 includes 拆分模板组件通常有两个好处：<br>模板可复用，减少重复代码<br>主模板结构清晰</p></li><li><p>中间件与 next<br>express 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递，如内置的 res.render 其实就是渲染完 html 直接返回给客户端，没有调用 next()，从而没有传递给下一个中间件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简介&lt;br&gt;中间件：在 express 应用中，一切皆中间件。各种应用逻辑，如 c
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="express" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>react+redux 项目流程</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/13/3.13/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/13/3.13/</id>
    <published>2020-03-12T14:23:48.000Z</published>
    <updated>2020-03-16T01:14:16.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="restful-Api-资源表现层状态转化"><a href="#restful-Api-资源表现层状态转化" class="headerlink" title="restful Api 资源表现层状态转化"></a>restful Api 资源表现层状态转化</h3><p>资源是一种信息实体，它可以有多种外在表现形式。我们把资源具体呈现出来的形式，叫做它的<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">表现层（Representation）</a>。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。<br>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生<a href="https://www.cnblogs.com/yuri2016/p/7204594.html" target="_blank" rel="noopener">状态转化（State Transfer）</a>。而这种转化是建立在表现层之上的，所以就是表现层状态转化。</p><h3 id="react-redux-小项目流程"><a href="#react-redux-小项目流程" class="headerlink" title="react+redux 小项目流程"></a>react+redux 小项目流程</h3><ol><li><p>先 render 组件</p></li><li><p>componentDidMount (最常见的 fetch data 的地方就是在 componentDidMount 里)</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> componentDidMount() &#123;</span><br><span class="line"> <span class="comment">/*因为有 action 被发现</span></span><br><span class="line"><span class="comment">  一被调用立即执行 dispatch function</span></span><br><span class="line"><span class="comment">  store.dispatch(fetchpost());</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">this</span>.props.fetchPosts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>action creator 对 api 请求负责初始化<br>export default axios.create({<br>baseURL: <a href="https://jsonplaceholder.typicode.com" target="_blank" rel="noopener">https://jsonplaceholder.typicode.com</a><br>});</p></li><li><p>action creator 使用 axios 去做出 api 请求<br>action 会被立刻 dispatch 被 reducers 执行，但是 api 请求是有 delay 的。所以需要异步 action creator，即中间件 redux-thunk 帮助我们能去完成发出请求的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchPosts = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">async</span> (dispatch, getstate) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> json.get(<span class="regexp">/posts);</span></span><br><span class="line"><span class="regexp">dispatch(&#123; type: FETCH_POSTS, payload: response.data &#125;);</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export const fetchUser = id =&gt; async dispatch =&gt; &#123;</span></span><br><span class="line"><span class="regexp">const response = await json.get(`/u</span>sers/$&#123;id&#125;<span class="string">`);</span></span><br><span class="line"><span class="string">dispatch(&#123; type: FETCH_USER, payload: response.data &#125;);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>async 函数返回值是 Promise 对象，给了我们获取 data 的权限。<br>中间件：action creator 返回 function 或者 object，被 dispatch 到中间件，在中间件里会有 if 判断是 function 还是 object；如果是 obj，会直接到 reducers 里；如果是 function，会调用这个 function 以及 dispatch 和 getstate function。</p></li><li><p>api 返回 data<br>dispatch({ type: FETCH_POSTS, payload: response.data });</p></li><li><p>action creator 返回一个带有 fetched data 的 action，dispatch 给 reducers。</p></li><li><p>reducer 接收 action 并且通过 payload 数据返回一个新 state。<br>注意：<br>必须返回除了 undefined 以外的值 []是可以的；<br>state = null，第一次调用 state 默认是 null，表示现在没有被选择的值；<br>第二次调用的时候，state 是由第一次 return 出来的 state 和 action2 产生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = [], action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> FETCH_USER:</span><br><span class="line">      <span class="keyword">return</span> [...state, action.payload];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>新的 state 会被作为 props 传入 react 组件，造成重新渲染。store 可以看作是 state 的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">posts</span>: state.posts &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; fetchPosts &#125;)(PostList);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;restful-Api-资源表现层状态转化&quot;&gt;&lt;a href=&quot;#restful-Api-资源表现层状态转化&quot; class=&quot;headerlink&quot; title=&quot;restful Api 资源表现层状态转化&quot;&gt;&lt;/a&gt;restful Api 资源表现层状态转化&lt;/
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="react" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"/>
    
      <category term="restful api" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/restful-api/"/>
    
  </entry>
  
  <entry>
    <title>Redux</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/12/3.12/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/12/3.12/</id>
    <published>2020-03-11T14:23:48.000Z</published>
    <updated>2020-03-16T01:26:02.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><ol><li><p>redux 作用？<br>随着应用复杂度地不断提升，组件之间的状态通信变得越来越多，组件之间的耦合也变得越来越重。redux 能更好维护的模块间通信。</p></li><li><p>Redux 的单一状态树<br>所有的 state 都以一个对象树的形式储存在一个单一的 store 中。页面中的所有状态 or 数据，都应该用这种状态树的形式来描述；页面上的任何变化，都应该先去改变这个状态树，然后再通过某种方式实现到页面上。</p></li><li><p>action</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"CHANGE_TEXT"</span>,</span><br><span class="line">    payload: <span class="string">"Hello"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Action 的任务是描述“发生了什么事情？”，这个函数会返回一个 Action 对象，这个对象里描述了“页面发生了什么”。随后这个对象会被传入到 Reducer 中。</p></li><li><p>reducer<br>(state, action) =&gt; newState<br>Reducer 的任务是根据传入的 Action 对象去修改状态树。<br>Reducer 是一个纯函数， 根据传入的 当前 state 和 action ，返回一个新的 state 。</p></li><li><p>Store<br>let store = createStore(Reducer);<br>state 是 store 的映射；<br>Store 就是把 Reducer 和 action 联系到一起的对象。<br>Store 有以下职责：<br>维持应用的 state；<br>提供 getState() 方法获取 state；<br>提供 dispatch(action) 方法更新 state；<br>通过 subscribe(listener) 注册监听器；</p></li><li><p>异步操作怎么办？<br>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。中间件解决了这个问题。</p></li><li><p>什么是中间件？<br>中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p></li></ol><p>摘自：<a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">阮一峰</a> <a href="https://zhuanlan.zhihu.com/p/24684803" target="_blank" rel="noopener">知乎 er</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redux 作用？&lt;br&gt;随着应用复杂度地不断提升，组件之间的状态通信变得越来越多，组件之间的耦合
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="redux" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/11/3.11/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/11/3.11/</id>
    <published>2020-03-10T14:23:48.000Z</published>
    <updated>2020-03-16T01:26:35.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><ol><li><p>webpack 作用及流程<br>component 必须返回 jsx，每次当 state 变化，组件重新渲染<br>比如 webpack 会把 jsx 语句转化为 bundle.js<br><a href="https://juejin.im/entry/58a177b0128fe100659d79ef" target="_blank" rel="noopener">webpack 流程介绍</a></p></li><li><p>express 项目结构<br>其中 app.js 是入口文件，views 文件夹下面放置的是需要渲染的模板文件，package.json 是整个项目的配置文件，.gitignore 文件里面写明文件 pull 到 github 时不需要上传的文件或文件夹，如 node_modules 文件夹。</p></li><li><p><a href="https://www.zybuluo.com/kexinWeb/note/663277" target="_blank" rel="noopener">app.js</a></p></li><li><p>js 框架与模板引擎的区别<br>模板引擎，就是将 HTML 模板渲染出最终样子的工具。<br>把动态把数据填充到 HTML 里面，可以在服务器端做，也可以在浏览器端做<br>比如 angular 会根据取到的数据去填充}里的内容，这是在客户端完成的。<br>比如 JSP 会在服务器端去填充{$}里的内容，然后把最终的 html 送到浏览器，这是服务器端完成的。<br>有时候前后端模板引擎会同时使用，即使有前端的模板引擎，后端返回 HTML 有时也是需要的，不仅仅返回是 JSON 数据<br>区别：<br>前后端分离可以大大将服务端的压力分散给客户端，而客户端的计算性能损耗几乎是微乎其微，并且在开发流程上，效率也极大提升，也可以适应敏捷开发。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;webpack 作用及流程&lt;br&gt;component 必须返回 jsx，每次当 s
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="express" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/10/3.10/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/10/3.10/</id>
    <published>2020-03-09T14:23:48.000Z</published>
    <updated>2020-03-17T11:33:06.253Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol><li><p>什么是 Webpack?<br>WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。</p></li><li><p>为什要使用 WebPack?<br>今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的 JavaScript 代码和一大堆依赖包。为了简化开发的复杂度，有不少好的实践方法<br>a:模块化，让我们可以把复杂的程序细化为小的文件;<br>b:类似于 TypeScript 这种在 JavaScript 基础上拓展的开发语言：使我们能够实现目前版本的 JavaScript 不能直接使用的特性，并且之后还能能装换为 JavaScript 文件使浏览器可以识别。</p></li><li><p>Webpack 的工作方式是?<br>在 webpack 看来一切都是模块！他会把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个浏览器可识别的 JavaScript 文件。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是 Webpack?&lt;br&gt;WebPack 可以看做是模块打包机：它做的事情是
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="webpack" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/09/3.9/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/09/3.9/</id>
    <published>2020-03-08T14:23:48.000Z</published>
    <updated>2020-03-16T00:40:22.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-hook"><a href="#react-hook" class="headerlink" title="react hook"></a>react hook</h3><ol><li><p>React 的核心思想是，一个 UI 组件响应一个 state 变化。</p></li><li><p>不使用 setState 更新 React 中的 state。<br>React 组件不再是 ES6 class，它是一个纯粹而简单的 JavaScript 函数。<br>const [buttonText, setButtonText] = useState(“Click me, please”);<br>[state 值,state 更新函数]</p></li><li><p>useEffect 获取数据替代 componentDidMount 在 React 中获取数据。<br>useEffect 与 React 类中的 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途，但统一为单个 API。<br>比如，在 useEffect 中调用 fetch。而且可以使用 setData（从 useState 中提取的更新函数）代替 this.setState。<br>“useEffect 与 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途”<br>componentDidUpdate！ componentDidUpdate 是一个生命周期方法，每当组件获得新的 props 或 state 发生变化时就会运行。如果直接调用 useEffect，你会看到无限循环。我们需要传递一个空数组作为 useEffect 的第二个参数：[]。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">"http://localhost:3001/links/"</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> setData(data));</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用带有 React Hooks 的 render props 吗？<br>没有意义。那是因为 React Hooks 诞生的原因的：在组件之间共享逻辑。有了一个标准的、干净的方式来封装和共享逻辑。</p></li><li><p>可以在 useEffect 中使用 async/await 吗?<br>不能直接使用。那是因为 JavaScript 异步函数总是返回一个 promise，而 useEffect 只能返回另一个函数。如果你要在 useEffect 中使用 setInterval 定时器，我们应该返回一个函数（闭包）来清除 setInterval。</p></li></ol><p>摘自：<a href="https://fenews.org/posts/getting-started-with-react-hooks/" target="_blank" rel="noopener">React Hooks(2019)入门教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;react-hook&quot;&gt;&lt;a href=&quot;#react-hook&quot; class=&quot;headerlink&quot; title=&quot;react hook&quot;&gt;&lt;/a&gt;react hook&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;React 的核心思想是，一个 UI 组件响应一个 sta
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="react hooks" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/react-hooks/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/08/3.8/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/08/3.8/</id>
    <published>2020-03-07T14:23:48.000Z</published>
    <updated>2020-03-10T05:44:07.970Z</updated>
    
    <content type="html"><![CDATA[<p>今天算是做完了 9321 的第一个 assignment，考察了对 python 里几个包的运用，pandas、matplotlib 等，主要是用 python 进行数据处理和可视化，还是蛮简单的。</p><p>顺便记录一下 <a href="https://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">git</a> 的基本操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天算是做完了 9321 的第一个 assignment，考察了对 python 里几个包的运用，pandas、matplotlib 等，主要是用 python 进行数据处理和可视化，还是蛮简单的。&lt;/p&gt;
&lt;p&gt;顺便记录一下 &lt;a href=&quot;https://www.bo
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="unsw" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/unsw/"/>
    
      <category term="git" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Node</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/07/3.7/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/07/3.7/</id>
    <published>2020-03-06T14:23:48.000Z</published>
    <updated>2020-03-07T14:52:01.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol><li><p>为什么说 nodejs 是单线程语言呢？这是因为 nodejs 中 javascript 代码的执行是单线程；但 node 确实只有一个主线程，但是底层工作的线程却有多个。遇到异步时，主线程发出操作指令，然后就可以去做别的事情了（主线程不需要等待），所有操作完成后再执行回调。主线程什么时候知道操作完成执行回调，则通过 event loop 机制循环遍历。</p></li><li><p>nodejs 的异步 IO<br>当需要 IO(网络 IO/文件 IO)操作时，单线程的 javascript 并不会停下来等待 IO 操作完成，而是“事件驱动”开始介入，javascript 执行线程继续执行未完的 javascript 代码，当执行完成后该线程处于空闲状态</p></li><li><p>事件循环<br><img src="/images/node_sys.png" alt=""><br>Node.js 应用启动时，V8 引擎会执行你写的应用代码，保持一份观察者（注册在事件上的回调函数）列表。当事件发生时，它的回调函数会被加进一个事件队列。只要这个队列还有等待执行的回调函数，事件循环就会持续把回调函数从队列中拿出并执行。</p></li></ol><p>4.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module 是一个 obj，有一个 exports 属性导出 function 或者 obj</span></span><br><span class="line"><span class="built_in">module</span>.exports.func = func</span><br><span class="line"><span class="built_in">module</span>.exports.endPoint = url (keep url private)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./相对路径"</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">const</span> pathObj = path.parse(\_\_filename)</span><br><span class="line"><span class="comment">//包含 dir 地址，root，name 等属性</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">"os"</span>)</span><br><span class="line"><span class="comment">//包含内存等等属性</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Node&quot;&gt;&lt;a href=&quot;#Node&quot; class=&quot;headerlink&quot; title=&quot;Node&quot;&gt;&lt;/a&gt;Node&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么说 nodejs 是单线程语言呢？这是因为 nodejs 中 javascript 代码的执行是单线
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="node" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JS</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/06/3.6/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/06/3.6/</id>
    <published>2020-03-05T14:23:48.000Z</published>
    <updated>2020-03-08T00:21:01.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS-高阶函数"><a href="#JS-高阶函数" class="headerlink" title="JS 高阶函数"></a>JS 高阶函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="comment">//handle in this array not a new array;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">const</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="comment">//handle in a new array;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//filter</span></span><br><span class="line"><span class="keyword">const</span> evens = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//return true or false;</span></span><br><span class="line">  <span class="comment">//true will put the item back to the new array</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce</span></span><br><span class="line"><span class="keyword">const</span> evens = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//prev item and next item will do some kind of calculation;</span></span><br><span class="line">  <span class="comment">//return a number</span></span><br><span class="line">&#125;, randomNumAsStartNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//some,every return true or false;</span></span><br><span class="line"><span class="comment">//some: if any item satisfy the condition,return true</span></span><br><span class="line"><span class="comment">//every: if all items satisfy the condition,return true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS-高阶函数&quot;&gt;&lt;a href=&quot;#JS-高阶函数&quot; class=&quot;headerlink&quot; title=&quot;JS 高阶函数&quot;&gt;&lt;/a&gt;JS 高阶函数&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="javascript" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>css grid</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/05/3.5/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/05/3.5/</id>
    <published>2020-03-04T14:23:48.000Z</published>
    <updated>2020-03-08T00:21:01.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="css-grid"><a href="#css-grid" class="headerlink" title="css grid"></a>css grid</h3><ol><li>grid 构成</li></ol><p>Grid Container) 应用 display: grid 的元素<br>网格项(Grid Item) 网格容器（Grid Container）的子元素（例如直接子元素）<br>网格线(Grid Line) 网格轨道(Grid Track) 网格单元格(Grid Cell) 网格区域(Grid Area)</p><ol start="2"><li><p>grid 属性<br>学习了各种网格容器属性以及网格项属性；<br>两个教程：<br><a href="https://www.html.cn/archives/8510" target="_blank" rel="noopener">https://www.html.cn/archives/8510</a><br><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p></li><li><p>网格容器与网格项结构<br><img src="/images/grid-1.png" alt=""><br><img src="/images/grid-2.png" alt=""></p></li><li><p>属性分为三大类：<br>grid container;grid item;以及 grid 里的 content</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;css-grid&quot;&gt;&lt;a href=&quot;#css-grid&quot; class=&quot;headerlink&quot; title=&quot;css grid&quot;&gt;&lt;/a&gt;css grid&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;grid 构成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Grid Container) 应用
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="css grid" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/css-grid/"/>
    
  </entry>
  
  <entry>
    <title>css flex box</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/04/3.4/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/04/3.4/</id>
    <published>2020-03-03T14:23:48.000Z</published>
    <updated>2020-03-16T01:14:46.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="css-flex-box"><a href="#css-flex-box" class="headerlink" title="css flex box"></a>css flex box</h3><p>在 flex 布局中，flex 项（就是子元素）要么按照 main axis(主轴)（从 main-start 到 main-end ）排布，要么按照 cross axis(交叉轴) (从 cross-start 到 cross-end)排布。了解六个容器属性等。</p><p>两个极好的教程:<br><a href="https://www.html.cn/archives/8629" target="_blank" rel="noopener">CSS3 Flexbox 布局完全指南</a><br><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰</a></p><p><img src="/images/background.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;css-flex-box&quot;&gt;&lt;a href=&quot;#css-flex-box&quot; class=&quot;headerlink&quot; title=&quot;css flex box&quot;&gt;&lt;/a&gt;css flex box&lt;/h3&gt;&lt;p&gt;在 flex 布局中，flex 项（就是子元素）要么按照 m
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="css flex box" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/css-flex-box/"/>
    
  </entry>
  
  <entry>
    <title>css box model and positioning</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/03/3.3/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/03/3.3/</id>
    <published>2020-03-03T01:57:48.000Z</published>
    <updated>2020-03-07T14:45:42.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="css-box-model"><a href="#css-box-model" class="headerlink" title="css box model"></a>css box model</h3><ol><li><p>所有元素在 css 里都会是一个 box； margin 是该 box 与其他 box 的距离，而 padding 是该盒子边界与内容区的距离</p></li><li><p>当两个 box 相邻时，margin 会塌陷（重叠），选 box margin 大的那一个作为距离</p></li><li><p>box-sizing 属性：border-box，内容区宽度或高度会自动调整<br>padding + border + 内容 width= 盒子的宽度<br>padding+ border + 内容 height = 盒子的高度<br><img src="https://s2.ax1x.com/2020/03/04/35aepD.png" alt="alt text"></p></li></ol><h3 id="css-positioning"><a href="#css-positioning" class="headerlink" title="css positioning"></a>css positioning</h3><ol><li><p>postion： 默认是 static relative 允许对元素的位置进行操作</p></li><li><p>absolute：相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。条件是定位基点（一般是父元素）不能是 static 定位， 否则定位基点是 html。</p></li><li><p>fixed：相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。</p></li><li><p>sticky：一些时候是 relative 定位（定位基点是自身默认位置），另一些时候自动变成 fixed 定位（定位基点是视口）</p></li></ol><p>摘自：<a href="https://www.ruanyifeng.com/blog/2019/11/css-position.html" target="_blank" rel="noopener">阮一峰教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;css-box-model&quot;&gt;&lt;a href=&quot;#css-box-model&quot; class=&quot;headerlink&quot; title=&quot;css box model&quot;&gt;&lt;/a&gt;css box model&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;所有元素在 css 里都会是一个 
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="css box model" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/css-box-model/"/>
    
      <category term="css positioning" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/css-positioning/"/>
    
  </entry>
  
  <entry>
    <title>Redux middleware</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/02/3.2/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/02/3.2/</id>
    <published>2020-03-02T07:57:48.000Z</published>
    <updated>2020-03-07T14:45:29.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redux-中间件"><a href="#redux-中间件" class="headerlink" title="redux 中间件"></a>redux 中间件</h3><ol><li><p>为什么要有中间件：目的是去处理一些在 redux 里的异步问题 store.dispath(action)是瞬时的，如果需要在 redux 里处理异步问题，则需要中间件来处理。</p></li><li><p>什么是中间件？（From Dan Abramov）<br>It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</p></li><li><p>实现一个异步功能的计数器？<br>如果在 view 里有一个 button 的 onClick 事件，用户每次点击 button，则会触发 addOne action creator 并且可以 dispatch action；<br>thunk 中间件允许我们 dispatch 出异步 function，它相比 reducers 是不纯净的；<br>然后经过 thunk 中间件，再传递给 reducer 对 action 进行处理，生成全新的 state；<br><img src="https://s2.ax1x.com/2020/03/03/34kEl9.png" alt="alt text"></p></li><li><p>其与小点<br>applyMiddlewares 作用是将所有中间件组成一个数组，依次执行，要注意中间件的次序；<br>view 和 state 是一一对应的，当 state 变化，view 会被重新渲染；<br>store.dispatch 方法会触发 Reducer 的自动执行；<br>一个 action 可能经过不同的中间件，当 action 不需要再被处理时，中间件会进行自己的“熔断”机制；</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redux-中间件&quot;&gt;&lt;a href=&quot;#redux-中间件&quot; class=&quot;headerlink&quot; title=&quot;redux 中间件&quot;&gt;&lt;/a&gt;redux 中间件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么要有中间件：目的是去处理一些在 redux 里的异步问题 s
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="redux middleware" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/redux-middleware/"/>
    
  </entry>
  
  <entry>
    <title>事件捕获及冒泡</title>
    <link href="https://github.com/kyrie96521/kyrie96521.github.io/2020/03/01/3.1/"/>
    <id>https://github.com/kyrie96521/kyrie96521.github.io/2020/03/01/3.1/</id>
    <published>2020-03-01T10:47:28.000Z</published>
    <updated>2020-03-17T11:33:06.253Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM-操作-amp-jQuery"><a href="#DOM-操作-amp-jQuery" class="headerlink" title="DOM 操作&amp;jQuery"></a>DOM 操作&amp;jQuery</h3><ol><li><p>在 jQuery 里必须是对 jQuery 对象进行操作，所以对象需要被包裹在$(obj)里,比如$(this.obj)</p></li><li><p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。即 child 事件先处理。<br><img src="https://s2.ax1x.com/2020/03/04/35UlJU.png" alt="alt text"><br>但事件捕获(event capturing)与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。<br>element.addEventListener(event, function, useCapture)<br>true - 事件在捕获阶段执行<br>false- 默认。事件在冒泡阶段执行</p></li><li><p>我们给一个 dom 同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？<br>非目标元素捕获 -&gt; 目标元素代码顺序 -&gt; 非目标元素冒泡<br><a href="https://blog.csdn.net/moguzhale/article/details/53503044" target="_blank" rel="noopener">https://blog.csdn.net/moguzhale/article/details/53503044</a></p></li><li><p>阻止冒泡和取消默认事件<br>event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用 event.preventDefault()可以取消默认事件<br><a href="https://www.jianshu.com/p/1fd066b4c0ba" target="_blank" rel="noopener">https://www.jianshu.com/p/1fd066b4c0ba</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DOM-操作-amp-jQuery&quot;&gt;&lt;a href=&quot;#DOM-操作-amp-jQuery&quot; class=&quot;headerlink&quot; title=&quot;DOM 操作&amp;amp;jQuery&quot;&gt;&lt;/a&gt;DOM 操作&amp;amp;jQuery&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在
      
    
    </summary>
    
    
    
      <category term="Daily juice" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/Daily-juice/"/>
    
      <category term="dom" scheme="https://github.com/kyrie96521/kyrie96521.github.io/tags/dom/"/>
    
  </entry>
  
</feed>
